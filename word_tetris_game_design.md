# 单词俄罗斯方块游戏设计方案

## 🎮 游戏概述

### 游戏名称

**Word Tetris** (单词俄罗斯方块)

### 核心理念

结合经典俄罗斯方块的游戏机制与英语单词学习，创造一个既有趣又有教育意义的语言学习游戏。学生通过填补缺失字母来"击落"下降的单词，在游戏中自然地学习和巩固英语词汇。

### 目标用户

- **主要用户**：小学 6 年级学生（11-12 岁）
- **辅助用户**：英语初学者、希望提高拼写能力的学习者
- **教育场景**：课堂教学、课后练习、家庭学习

### 游戏模式

游戏提供两种难度模式，适应不同学习阶段和能力的学生：

#### 😊 休闲模式（默认）
- **字母提示**：显示部分字母提示，降低难度
- **适合人群**：初学者、刚接触单词的学生
- **学习目标**：建立单词拼写的基础认知
- **推荐场景**：课堂教学、初次学习新单词

#### 🔥 挑战模式
- **全部隐藏**：所有缺失字母完全隐藏，无任何提示
- **适合人群**：已有一定基础的学生、复习巩固阶段
- **学习目标**：强化记忆，提升拼写准确性
- **推荐场景**：课后练习、单词复习、能力测试

#### 模式切换
- **设置位置**：游戏设置页面的"游戏模式"区域
- **切换方式**：单选按钮，点击即可切换
- **保存机制**：选择自动保存到本地存储，下次启动保持
- **实时生效**：切换后立即应用到游戏中

---

## 🎯 游戏机制设计

### 基础玩法

1. **单词下降**：完整单词从屏幕顶部缓冲区开始下降
2. **随机位置掉落**：**单词从游戏区域上方的随机水平位置开始掉落，而非固定在中间位置**
   - **位置计算**：根据单词长度计算随机 x 坐标，确保单词完全在画布内
   - **边距保护**：左右各留 20 像素边距，避免单词贴边显示
   - **随机范围**：`minX = 单词宽度/2 + 20`，`maxX = 画布宽度 - 单词宽度/2 - 20`
   - **游戏性提升**：增加游戏趣味性和挑战性，避免单调的固定位置
3. **字母缺失**：单词中随机缺失 1-2 个字母，显示为空格或下划线
4. **玩家输入**：玩家通过键盘实时输入缺失的字母，无需确认键
   - **支持字符**：英文字母（a-z）和连字符（`-`）
   - **连字符单词**：系统支持带连字符的复合词（如 `pencil-box`、`well-known`）
   - **输入验证**：连字符与字母使用相同的验证和显示逻辑
5. **炮管射击机制**：当输入的字母数量和内容完全正确时，底部炮管发射炮弹击中单词，单词爆炸消失
6. **错误处理**：输入错误字母时，在该字母上显示血色红叉，并清空所有输入等待重新输入
7. **放弃按键**：玩家可以按"放弃"按键（如空格键）将当前单词直接放入堆叠区
8. **堆叠机制**：只有放弃或输入错误的单词才会在堆叠区从底部向上堆叠
9. **顺序下降**：**只有当前单词被射击消失或放入堆叠区后，下一个单词才开始从缓冲区下降**
10. **语音朗读**：**单词开始下降时立即播放英式发音朗读，之后每 5 秒重复朗读一次，直到单词被射击击落或放入堆叠区为止**
11. **游戏结束**：堆叠区完全填满时游戏结束
12. **等级清空**：每次进入下一难度时，堆叠区清空并生成生词本

**游戏区域规则：**

- **缓冲区**：单词准备和倒计时区域

  - 单词首先出现在缓冲区
  - **信号灯倒计时**：红灯（1 秒）→ 黄灯（1 秒）→ 绿灯（1 秒）依次亮起
  - **重要**：必须确保绿灯完整亮起 1 秒钟
  - 绿灯亮起期间，单词开始匀速下降

- **统一游戏区域**：下降与堆叠的统一空间
  - **单个单词下降**：同时只有一个单词在游戏区域内下降
  - 玩家可以输入缺失字母或按"放弃"按键
  - **炮管射击**：输入完全正确时，底部炮管发射炮弹击中单词，单词爆炸消失
  - **错误反馈**：输入错误字母时显示血色红叉，清空输入重新开始
  - **手动放弃**：按"放弃"按键直接将单词放入堆叠区
  - **顺序机制**：当前单词被射击消失或放入堆叠区后，下一个单词才从缓冲区开始下降
  - **堆叠区用途**：专门存放放弃或失败的单词
  - **炮管位置**：位于游戏区域底部，瞄准当前下降的单词
  - 堆叠到顶部（接近缓冲区）时游戏结束
  - 每个难度结束时堆叠区清空

---

## 📊 难度与评分系统

### 难度等级设计

**基础速度设定：3 帧 1 像素**（初始下降速度）

| 等级  | 分数要求   | 下降速度                      | 缺失字母数 | 词汇难度     | 单词级别 |
| ----- | ---------- | ----------------------------- | ---------- | ------------ | -------- |
| 1 级  | 0-99 分    | 基础速度（3 帧 1 像素）       | 1 个字母   | 3-4 字母单词 | 难度1专用 |
| 2 级  | 100-199 分 | +5%速度（约 2.85 帧 1 像素）  | 1-2 个字母 | 4-5 字母单词 | 难度1专用 |
| 3 级  | 200-299 分 | +10%速度（约 2.7 帧 1 像素）  | 1-2 个字母 | 5-6 字母单词 | 难度2专用 |
| 4 级  | 300-399 分 | +15%速度（约 2.55 帧 1 像素） | 2 个字母   | 6-7 字母单词 | 难度2专用 |
| 5 级+ | 每 100 分  | +5%速度（递减）               | 2-3 个字母 | 复杂单词     | 难度3专用 |

### 🔒 单词级别互斥原则

#### 核心规则
- **严格分离**：每个单词只能属于一个难度级别
- **无重复**：同一单词不能同时出现在多个难度级别中
- **独立词库**：不同级别使用完全独立的单词集合
- **渐进难度**：确保学习路径的清晰性和连贯性

#### 级别分配策略
- **Level 1-2**：仅使用 `difficulty: 1` 的单词
- **Level 3-4**：仅使用 `difficulty: 2` 的单词
- **Level 5+**：仅使用 `difficulty: 3` 的单词

#### 技术实现
```javascript
// 严格筛选：只选择指定难度的单词，确保级别互斥
const filteredWords = this.allWords.filter(word => 
    word.difficulty === targetDifficulty
);
```

#### 质量保证
- **自动去重**：加载时自动检测并跳过重复单词
- **分布验证**：验证每个难度级别有足够的单词数量
- **警告机制**：当某个难度级别单词不足时发出警告

### 评分规则

- **基础分数**：每个正确字母 = 1 分
- **射击奖励**：成功射击单词额外+2 分
- **速度奖励**：快速射击单词额外+50%分数
- **连击奖励**：连续射击 3 个以上单词，每个额外+1 分
- **完美奖励**：一个等级内零失误（无单词进入堆叠区），额外+20 分
- **放弃惩罚**：使用"放弃"按键将单词放入堆叠区，-1 分

### 特殊机制

- **等级末尾挑战**：每个等级的最后 10 个单词，缺失字母数量+1
- **时间压力**：随着等级提升，给玩家思考的时间逐渐减少
- **信号灯机制详细说明**：
  - 第 1 秒：只有红灯亮起，黄灯和绿灯熄灭
  - 第 2 秒：只有黄灯亮起，红灯和绿灯熄灭
  - 第 3 秒：只有绿灯亮起，红灯和黄灯熄灭
  - 绿灯亮起的同时，单词开始下降
  - **关键**：绿灯必须完整显示 1 秒钟，不能被跳过
- **堆叠区管理**：
  - 堆叠区与游戏区域合并为统一空间
  - 单词按到达顺序从底部向上堆叠
  - 堆叠到接近缓冲区时触发游戏结束
- **等级转换机制**：
  - 达到等级分数要求时，堆叠区自动清空
  - 堆叠区中的所有单词自动加入生词本
  - 播放等级提升动画，显示生词本统计

---

## 🎨 界面设计方案

### 主游戏界面布局

```
┌──────────────────────────────────────────────────────────────────────────┐
│  分数: 156  等级: 2  目标: 200  生词本: 12  时间: 02:34                   │  ← 计分信息区
├──────────────────────────────────────────────────────────────────────────┤
│  考试总词量: 135  正确命中: 28 (21%)  覆盖率: 21%                        │  ← 考试统计栏
├──────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌─────────────┐  ┌──────────────────────────────────────────────────┐ │
│  │             │  │              单词缓冲区                           │ │
│  │   🖼️ 图片   │  │         🔴 🟡 🟢 信号灯                        │ │
│  │   展示区    │  ├──────────────────────────────────────────────────┤ │
│  │             │  │                                                  │ │
│  │  [图片]     │  │              h_ll_                               │ │ ← 当前单词
│  │             │  │                 ↑                                │ │
│  │  hello      │  │                                                  │ │
│  │  /heˈləʊ/   │  │                                                  │ │
│  │  你好        │  │          统一游戏区域                            │ │
│  │             │  │                                                  │ │
│  │  200x200px  │  │  [house] [cat] [dog] [tree] [book]              │ │ ← 堆叠区
│  │             │  │  [water] [happy] [sun] [moon]                   │ │
│  │             │  │  [star] [light] [red] [blue]                    │ │
│  │             │  │  [green] [yellow] [black]                       │ │
│  │             │  │  [white] [orange]                               │ │
│  │             │  ├──────────────────────────────────────────────────┤ │
│  │             │  │                    🔫                           │ │ ← 炮管
│  └─────────────┘  └──────────────────────────────────────────────────┘ │
│                                                                          │
├──────────────────────────────────────────────────────────────────────────┤
│  当前输入: [o]  实时显示: h[o]ll[❌]  [空格键: 放弃]                      │  ← 实时输入区域
└──────────────────────────────────────────────────────────────────────────┘
```

### 🖼️ 单词图片展示区设计

#### 设计理念

通过视觉化的图片展示，帮助学生建立**英文单词 ↔ 图像 ↔ 中文意思**的三重记忆关联，显著提升单词记忆效果和学习趣味性。

#### 位置与尺寸

- **位置**：游戏画布左侧，独立的图片展示区域
- **尺寸**：200px × 200px（正方形）
- **布局**：垂直居中对齐游戏画布
- **间距**：与游戏画布间隔 20px

#### 展示内容

**三层信息结构**（从上到下）：

1. **图片区域**（主体，占 70%）
   - 单词对应的视觉图片
   - 圆角设计（border-radius: 10px）
   - 图片填充模式：cover（保持比例裁剪）
   - 背景色：深灰色 (#2c3e50)

2. **单词信息区**（占 15%）
   - 英文单词：白色，18px，加粗，小写显示
   - 音标：浅蓝色 (#74c0fc)，14px，斜体

3. **中文翻译区**（占 15%）
   - 中文翻译：金黄色 (#ffd700)，16px，加粗
   - 背景：半透明黑色 rgba(0,0,0,0.5)

#### 视觉样式

- **边框**：2px 实线，渐变金色边框
  ```css
  border: 2px solid;
  border-image: linear-gradient(135deg, #ffd700, #ffed4e) 1;
  ```
- **阴影**：柔和的外发光效果
  ```css
  box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
  ```
- **背景**：半透明深色背景
  ```css
  background: rgba(30, 60, 114, 0.8);
  backdrop-filter: blur(10px);
  ```

#### 动画效果

1. **图片加载动画**（淡入效果）
   - 持续时间：0.5 秒
   - 效果：从透明度 0 渐变到 1
   - 缓动函数：ease-in-out

2. **单词切换动画**（滑动 + 淡入淡出）
   - 旧单词淡出：0.3 秒，向左滑动 20px
   - 新单词淡入：0.3 秒，从右侧滑入 20px
   - 总时长：0.6 秒

3. **加载中动画**（脉冲效果）
   - 显示加载占位符
   - 脉冲动画：缩放 1.0 ↔ 1.05
   - 循环播放直到图片加载完成

4. **成功射击特效**
   - 图片区域闪烁绿色边框（3 次）
   - 每次闪烁 0.2 秒
   - 边框颜色：#4caf50

5. **错误输入特效**
   - 图片区域轻微抖动（shake 动画）
   - 持续时间：0.5 秒
   - 抖动幅度：±5px

#### 图片来源策略

**多层级降级方案 + 自动缓存机制**，确保始终有图片显示：

1. **优先级 1：本地缓存目录**（最快，最可靠）
   - **路径**：`proj/images/cache/{word}.jpg`
   - **用途**：自动缓存从 API 下载的图片
   - **优点**：
     - 加载速度极快（本地读取）
     - 无网络依赖（下载后离线可用）
     - 节省带宽（避免重复下载）
     - 自动管理（无需手动维护）
   - **工作流程**：
     1. 首次：从 API 下载 → 保存到缓存目录 → 显示
     2. 再次：直接从缓存目录读取 → 显示

2. **优先级 2：预置图片库**（可选）
   - **路径**：`proj/images/words/{word}.jpg`
   - **用途**：预先准备的高质量单词图片
   - **优点**：
     - 图片质量可控
     - 适合特定教学需求
     - 适合离线部署
   - **缺点**：需要手动准备和维护

3. **优先级 3：免费图片 API**（自动获取）
   - **Unsplash API**（推荐）
     - URL: `https://source.unsplash.com/200x200/?{word}`
     - 优点：高质量图片，免费，无需 API key
     - 缺点：需要网络连接
   - **下载后处理**：
     - 自动保存到缓存目录
     - 记录下载时间和元数据
     - 下次直接使用缓存

4. **优先级 4：图标字体**（降级方案）
   - 使用 Font Awesome 或 Material Icons
   - 显示与单词相关的图标
   - 背景色：渐变色彩

5. **优先级 5：纯色占位符**（最终降级）
   - 显示单词首字母大写
   - 随机渐变背景色
   - 字体：超大号，白色

#### 图片缓存目录管理

**自动化图片缓存系统**：

1. **目录结构**
   ```
   proj/images/
   ├── cache/              # 自动缓存目录（API下载的图片）
   │   ├── hello.jpg
   │   ├── cat.jpg
   │   ├── dog.jpg
   │   └── ...
   ├── words/              # 预置图片库（可选，手动准备）
   │   ├── hello.jpg
   │   ├── world.jpg
   │   └── ...
   └── .gitignore          # 忽略 cache 目录（不提交到 Git）
   ```

2. **缓存策略**
   - **检查顺序**：
     1. 检查缓存目录是否有该单词图片
     2. 检查预置图片库是否有该单词图片
     3. 从 API 下载并保存到缓存目录
     4. 降级到图标字体或占位符
   
   - **文件命名**：`{word}.jpg`（单词小写，统一使用 jpg 格式）
   
   - **元数据记录**：`cache-metadata.json`
     ```json
     {
       "hello": {
         "downloadTime": "2025-10-06T12:00:00Z",
         "source": "unsplash",
         "fileSize": 15360,
         "lastAccess": "2025-10-06T15:30:00Z"
       }
     }
     ```

3. **缓存清理**
   - **容量限制**：最多缓存 500 个图片文件
   - **清理策略**：LRU（最近最少使用）
   - **清理时机**：
     - 达到容量限制时自动清理
     - 提供手动清理按钮
     - 可设置自动清理间隔
   - **清理规则**：
     - 保留最近 30 天访问的图片
     - 删除超过 90 天未访问的图片
     - 按 lastAccess 排序，删除最旧的

4. **下载管理**
   - **并发控制**：最多同时下载 3 个图片
   - **下载队列**：超过并发限制时排队等待
   - **失败重试**：下载失败最多重试 3 次
   - **超时控制**：单个图片下载超时 10 秒
   - **进度显示**：显示下载进度（可选）

5. **离线支持**
   - 检测网络状态
   - 离线时只使用缓存和预置图片
   - 联网后自动下载缺失的图片
   - 后台预加载常用单词图片

6. **Git 管理**
   - **`.gitignore` 配置**：
     ```
     # 图片缓存目录（不提交到 Git）
     proj/images/cache/
     proj/images/cache-metadata.json
     
     # 预置图片库（可选提交）
     # proj/images/words/
     ```
   - **原因**：
     - 缓存文件是动态生成的，每个用户不同
     - 避免仓库体积过大
     - 预置图片库可选择性提交

#### 图片缓存机制

- **本地存储缓存**：
  - 使用 `localStorage` 缓存图片 URL
  - 缓存键：`wordImage_{word}`
  - 缓存时长：7 天
  - 缓存大小限制：最多 100 个单词

- **预加载机制**：
  - 当前单词图片加载完成后，预加载下一个单词图片
  - 提升切换流畅度

#### 触发时机

1. **单词进入缓冲区时**
   - 立即开始加载图片
   - 显示加载动画

2. **单词开始下降时**
   - 图片应已加载完成
   - 执行淡入动画

3. **单词被射击击落时**
   - 执行成功特效（绿色闪烁）
   - 0.5 秒后切换到下一个单词

4. **单词被放弃或堆叠时**
   - 无特效，直接切换到下一个单词

#### 错误处理

- **图片加载失败**：
  - 自动尝试下一个优先级的图片源
  - 最多重试 3 次
  - 最终显示占位符

- **网络超时**：
  - 超时时间：5 秒
  - 超时后立即切换到降级方案

- **无图片可用**：
  - 显示友好的占位符
  - 不影响游戏进行

#### 教育价值

1. **多感官学习**：
   - 视觉（图片）+ 听觉（语音）+ 动作（输入）
   - 三重刺激，增强记忆

2. **情境关联**：
   - 图片提供单词的使用情境
   - 帮助理解单词的实际含义

3. **趣味性提升**：
   - 丰富的视觉内容
   - 降低学习疲劳感

4. **即时反馈**：
   - 图片特效配合游戏反馈
   - 增强成就感

#### 性能优化

- **图片压缩**：
  - 自动压缩到 200x200px
  - 使用 WebP 格式（支持的浏览器）
  - 降级到 JPEG（不支持 WebP 的浏览器）

- **懒加载**：
  - 只加载当前和下一个单词的图片
  - 避免一次性加载所有图片

- **内存管理**：
  - 及时释放已使用的图片资源
  - 限制缓存数量

### 视觉设计要素

- **颜色方案**：

  - 背景：深蓝色渐变
  - 单词：白色/黄色文字，**统一使用小写字母显示**
  - **重音音节高亮**：**重音音节的字母用红色显示**（#ff4444），帮助学生学习正确发音重音
    - 依据音标中的重音符号（ˈ 主重音，ˌ 次重音）
    - 优先显示主重音音节
    - 单音节词（无重音符号）不高亮
    - 示例：father = **fa**ther（红色），about = a**bout**（红色）
  - 缺失字母：红色下划线
  - 正确输入字母：绿色高亮显示，**字体比其他字母大 1.2-1.5 倍**
  - 错误输入字母：血色红叉（❌）覆盖显示
  - 完全正确单词：金色边框高亮，准备射击
  - 炮管：金属灰色，瞄准当前单词
  - 炮弹轨迹：橙色/黄色光束效果
  - 爆炸特效：多彩粒子爆炸动画
  - **中文翻译显示**：爆炸时炸出该单词的中文翻译，字体比英文单词大 2-3 倍
  - 堆叠单词：灰色显示（放弃或失败的单词）
  - **图片展示区**：金色渐变边框，半透明背景，柔和外发光

- **动画效果**：

  - 单词平滑下降
  - 实时输入字母的高亮反馈
  - **输入字母放大**：玩家输入的字母逐渐放大到 1.2-1.5 倍
  - **炮管射击动画**：炮弹从炮管发射到单词的轨迹动画
  - **爆炸特效**：单词被击中时的多彩粒子爆炸效果
  - **中文翻译爆炸动画**：
    - 英文单词消失的同时，中文翻译从小到大弹出
    - 中文字体从 0.5 倍放大到 2-3 倍大小
    - 中文显示 1-2 秒后淡出消失
    - 配合粒子爆炸效果，营造震撼的视觉冲击
  - **错误反馈动画**：错误字母上血色红叉的闪烁显示
  - **输入清空动画**：错误后所有输入字母的淡出效果
  - 放弃单词时的下沉到堆叠区动画
  - 完全正确时的金色闪烁特效
  - 分数增加的飞行动画
  - 等级提升的庆祝动画

- **音频效果**：
  - **单词朗读**：单词开始下降时自动播放英式发音
  - **重复朗读**：每 5 秒自动重复播放，强化听力记忆
  - **朗读停止**：单词被击落或堆叠时立即停止朗读

### 🔫 大炮系统设计

大炮是游戏的核心视觉元素和交互机制，采用卡通风格设计，兼具美观性和功能性。

#### 整体结构

大炮由四个主要部分组成：**堡垒基座** + **炮台平台** + **炮管主体** + **燃烧引信**

```
        🔫 炮口（粗圆柱体，蓝色装饰）
         |
         | 炮管前段（细长，金属渐变）
         |\
         | \🔥 燃烧引信（柔软绳子，物理摆动）
         |   └─> 火焰粒子（沿引信方向飘动）
         | 炮管中段（略细，金属渐变）
         |
         | 炮管后段（粗，金属渐变）
         |
        ⚙️ 炮台平台（圆柱形，连接基座）
         |
       🏰 堡垒基座（半圆形，石质）
```

**视觉层次**（从底到顶）：
1. 堡垒基座（最底层，稳固不动）
2. 炮台平台（连接层，随炮管旋转）
3. 炮管主体（主要元素，可旋转 + 后坐力）
4. 炮口装饰（顶端元素，蓝色科技感）
5. 燃烧引信（动态元素，物理摆动 + 粒子效果）

#### 1. 堡垒基座设计

**形状与尺寸**：
- **形状**：真正的半圆形（非椭圆）
- **半径**：60px
- **直径**：120px
- **高度**：60px（从圆心到底部）
- **位置**：始终保持水平，不随炮管旋转

**材质与质感**：
- **石质效果**：灰色系渐变（`#8B8D8F` → `#7F8C8D` → `#6C7A7E` → `#5D6D7E`）
- **不规则纹理**：
  - 10个随机分布的石块斑点（大小10-18px）
  - 每个石块有深色主体 + 浅色高光
  - 6条不规则裂纹线，模拟自然石头裂痕
- **光影效果**：
  - 左侧高光（白色，15%透明度）
  - 右侧阴影（黑色，20%透明度）
  - 底部阴影（黑色，40%透明度）

**装饰细节**：
- 深色轮廓线（3px，`#2C3E50`）
- 底部平面（120px宽，6px高，深灰色）
- 底部边缘线（2px，`#1A252F`）

**特殊属性**：
- ✅ 不受炮管后坐力影响
- ✅ 始终保持水平状态
- ✅ 固定在游戏区域底部

#### 2. 炮台平台设计

**功能**：连接堡垒基座和炮管，提供旋转支点

**结构**：
- **底部圆柱**：50px宽，12px高
- **顶部椭圆**：25px半径（水平），8px半径（垂直）
- **材质**：金属灰色渐变（`#5D6D7E` → `#7F8C8D`）

**装饰**：
- 装饰环：深灰色线条（2px）
- 高光效果：左侧白色高光

**运动特性**：
- 随炮管一起旋转
- 受后坐力影响

#### 3. 炮管主体设计

**三段式结构**：

1. **炮管后段**（粗）
   - 尺寸：30px宽 × 30px长
   - 位置：-50px 到 -20px
   - 颜色：深灰到浅灰金属渐变

2. **炮管中段**（略细）
   - 尺寸：26px宽 × 30px长
   - 位置：-75px 到 -45px
   - 颜色：灰蓝色金属渐变

3. **炮管前段**（细长）
   - 尺寸：22px宽 × 35px长
   - 位置：-105px 到 -70px
   - 颜色：深灰金属渐变

**金属质感**：
- **渐变色**：`#2C3E50` → `#34495E` → `#4A5F7F` → `#34495E` → `#2C3E50`
- **左侧高光**：白色，25%透明度，6px宽
- **右侧阴影**：黑色，30%透明度，5px宽
- **分段装饰环**：3条深色横线（-48px, -73px, -98px）

**工业装饰**：
- **铆钉**：12个（6对），左右对称
- **铆钉位置**：Y坐标 -45, -35, -70, -60, -95, -85
- **铆钉效果**：深色主体 + 白色高光

#### 4. 炮口设计

**形状**：粗圆柱体（比炮身粗）

**尺寸**：
- **圆柱宽度**：36px（炮身22px，炮口粗1.6倍）
- **圆柱长度**：13px
- **位置**：-118px 到 -105px

**视觉效果**：
- **主体**：金属渐变圆柱体
- **蓝色装饰**：
  - 底部边缘蓝色线（2px，`#3498DB`）
  - 前端面蓝色渐变（`#2C3E50` → `#3498DB` → `#5DADE2`）
  - 蓝色光环（2.5px，`#5DADE2`）
- **高光**：左上角白色高光（60%透明度）

**特点**：
- 圆柱体侧面，非球形端面
- 蓝色科技感装饰
- 发射准备指示灯位置

#### 5. 燃烧引信系统（发射准备指示）

**位置**：炮管侧面（18px, -60px）

**状态显示**：
- **无目标**：不显示
- **有目标**：燃烧引信效果

**引信结构**：
- **形态**：柔软绳子（非硬直柱体）
- **长度**：12px
- **材质**：深棕色线条（`#3E2723`，2px宽）
- **端点样式**：圆角（lineCap: 'round'）
- **固定点**：炮管侧面（18, -60）
- **自由端**：受重力影响摆动

**物理摆动系统**：

引信采用真实物理模拟，像钟摆一样自然摆动：

1. **重力系统**：
   - 重力影响：0.3（向下拉力）
   - 总是向世界坐标系下方（90°）
   - 自动转换到炮管坐标系

2. **摆动算法**：
   ```
   目标角度 = 世界下方向(π/2) - 炮管角度
   角加速度 = sin(目标角度 - 当前角度) × 重力
   角速度 += 角加速度
   角速度 × 阻尼系数(0.95)
   角度 += 角速度
   ```

3. **运动特性**：
   - ✅ 炮管转动时引信摆动跟随
   - ✅ 有惯性效果（摆动逐渐减弱）
   - ✅ 阻尼系数 0.95（防止无限摆动）
   - ✅ 角速度和角度实时更新

4. **物理表现**：
   - 炮管向上：引信自然下垂
   - 炮管转动：引信摆动跟随
   - 炮管静止：引信逐渐稳定
   - 炮管快速转动：引信甩动明显

**燃烧效果**：

1. **引信末端燃点**：
   - **发光层**：橙黄色径向渐变（半径 6px）
     - 颜色：`#FFC800` → `#FF6400` → 透明
   - **亮核心**：闪烁黄白色（半径 2px）
     - 颜色：`rgba(255, 255, 200, 0.7-1.0)`
     - 闪烁：正弦波动画（10ms 周期）

2. **火焰粒子系统**：
   - **生成频率**：40% 概率/帧
   - **生成位置**：引信末端 ± 2px 随机偏移
   - **运动方向**：沿引信延伸方向
     - 基础速度：1.5-2.5 像素/帧
     - 扩散角度：±15°（更自然）
   - **粒子属性**：
     - 大小：1.5-3px（径向发光）
     - 颜色：橙色/黄色随机（`#FFC800` / `#FF6400`）
     - 生命周期：50帧（约1秒）
     - 衰减速度：2%/帧
   - **物理效果**：
     - 轻微重力：+0.05/帧（vy 方向）
     - 沿引信方向飘动
     - 逐渐淡出消失

3. **火花效果**：
   - **生成频率**：5% 概率/帧（稀疏）
   - **特点**：
     - 颜色：亮黄白色（`#FFFFC8`）
     - 速度：2-4 像素/帧（更快）
     - 方向：引信方向 ± 30°
     - 效果：迸发感，增强动态
   - **用途**：增加细节，营造真实燃烧感

**视觉分层**：
```
第1层：引信绳子（深棕色线条）
第2层：末端发光（橙黄色渐变）
第3层：闪烁亮核（黄白色）
第4层：火焰粒子（动态飘动）
第5层：火花效果（偶尔迸发）
```

**技术细节**：

1. **坐标系转换**：
   - 世界坐标系：Y轴向下 = 90° = π/2
   - 炮管坐标系：随炮管旋转
   - 引信角度：相对炮管的局部角度

2. **末端位置计算**：
   ```javascript
   fuseEndX = attachX + sin(angle) × length
   fuseEndY = attachY + cos(angle) × length
   ```

3. **火焰方向计算**：
   ```javascript
   flameVx = sin(fuseAngle) × speed
   flameVy = cos(fuseAngle) × speed
   ```

4. **性能优化**：
   - 粒子自动清理（life <= 0）
   - 无内存泄漏
   - 每帧更新 20-30 个粒子

**游戏意义**：

- **状态提示**：引信燃烧表示"准备发射"
- **视觉统一**：火炮主题（炮管→引信→火球→爆炸）
- **沉浸感**：真实物理摆动，增强代入感
- **细节品质**：精致的粒子效果提升游戏质感

#### 6. 炮管瞄准系统

**瞄准机制**：
- 自动跟踪当前下落单词
- 平滑旋转动画（20%插值速度）
- 角度从Y轴负方向开始计算

**瞄准范围**：
- 向上：-90度（垂直向上）
- 向左：最多-45度
- 向右：最多+45度

**旋转中心**：
- 位置：画布底部中心（x: canvasWidth/2, y: canvasHeight-30）
- 炮管围绕此点旋转

#### 7. 后坐力系统

**触发条件**：每次发射炮弹时

**运动效果**：
- **后退距离**：20像素（增强视觉冲击）
- **衰减速度**：12%/帧（降低衰减以延长后坐力效果）
- **运动方向**：沿炮管方向向后
- **最小阈值**：0.1像素（低于此值归零）

**物理模拟**：
```javascript
// 触发后坐力
cannon.recoil = 20;  // 初始后退距离

// 每帧更新
cannon.recoil *= 0.88;  // 衰减（1 - 0.12）
if (cannon.recoil < 0.1) {
    cannon.recoil = 0;  // 归零
}
```

**影响范围**：
- ✅ 炮管主体（三段式全部）
- ✅ 炮台平台（圆柱和椭圆）
- ✅ 炮口装饰（蓝色圆柱）
- ✅ 燃烧引信（随炮管后退）
- ✅ 铆钉装饰
- ❌ 堡垒基座（稳固不动）

**视觉效果**：
- **射击瞬间**：炮管明显后退 20px
- **恢复过程**：约 20-25 帧逐渐恢复
- **基座对比**：基座稳固不动，形成反差
- **真实感**：模拟真实火炮射击的后坐力
- **冲击力**：增强射击的视觉冲击感和成就感

**设计意图**：
- 后坐力 20px 比原来的 10px 增加一倍
- 衰减速度从 15% 降至 12%，延长后坐力持续时间
- 让玩家更明显地感受到"射击"的力量感
- 配合火球发射和爆炸效果，形成完整的视觉反馈链

#### 8. 火球炮弹设计

**发射位置**：
- 从炮口前端发射（118px距离）
- 根据炮管旋转角度计算准确位置
- 公式：`muzzleX = cannon.x + sin(angle) × 118`
        `muzzleY = cannon.y - cos(angle) × 118`

**火球视觉效果**：

**三层结构**：
1. **外层光晕**（红色）
   - 半径：16px
   - 颜色：`#FF6400` → `#FF3200` → `#FF0000`（渐变到透明）
   - 透明度：80% → 40% → 0%

2. **中层火球**（橙色）
   - 半径：10px
   - 颜色：`#FFC800` → `#FF9600` → `#FF6400`
   - 透明度：100%

3. **内核**（亮黄色）
   - 半径：5px
   - 颜色：`#FFFFC8` → `#FFFF64` → `#FFC800`
   - 透明度：100%

**火焰纹理**：
- 6个旋转的火苗点
- 位置：围绕中心8px半径圆周
- 大小：4px半径
- 颜色：黄白色渐变，60%透明度

**动画效果**：
- **旋转**：每帧0.3弧度
- **速度**：15像素/帧
- **飞行轨迹**：直线追踪目标

**火焰尾迹**：
- **长度**：20个尾迹点（加长一倍）
- **渐变透明度**：从后到前逐渐增强
- **颜色渐变**：`#FFC800` → `#FF6400` → `#FF3200`
- **尾迹大小**：12px（尾部）→ 0px（头部）
- **更新频率**：每帧添加新点，移除最旧点

**碰撞检测**：
- 检测距离：20px
- 击中后触发爆炸效果

#### 颜色代码速查表

| 元素 | 颜色代码 | 说明 |
|------|----------|------|
| 基座主体 | `#8B8D8F` → `#5D6D7E` | 石质灰色渐变 |
| 基座轮廓 | `#2C3E50` | 深灰色 |
| 炮管金属 | `#2C3E50` → `#4A5F7F` | 金属灰蓝渐变 |
| 炮口蓝色 | `#3498DB` → `#5DADE2` | 蓝色科技感 |
| 引信绳子 | `#3E2723` | 深棕色 |
| 引信燃点 | `#FFC800` → `#FF6400` | 橙黄渐变发光 |
| 引信亮核 | `rgba(255, 255, 200, 0.7-1.0)` | 黄白色闪烁 |
| 火焰粒子 | `#FFC800` / `#FF6400` | 橙黄色随机 |
| 火花粒子 | `#FFFFC8` | 亮黄白色 |
| 火球外层 | `#FF6400` → `#FF0000` | 橙红渐变 |
| 火球中层 | `#FFC800` → `#FF6400` | 橙黄渐变 |
| 火球内核 | `#FFFFC8` → `#FFC800` | 亮黄渐变 |

#### 教育意义

**视觉反馈**：
- 炮管瞄准动画提示当前目标
- 燃烧引信提示可射击状态（替代简单指示灯）
- 引信摆动增加动态感和真实感
- 后坐力效果增强射击成就感

**游戏性**：
- 精准的瞄准系统提升挑战性
- 震撼的火球效果增强沉浸感
- 物理模拟的引信摆动增加细节品质
- 流畅的动画提升整体游戏体验

**技术实现**：
- Canvas 2D 渐变和路径绘制
- 实时角度计算和旋转变换
- 物理引擎：重力、摆动、阻尼模拟
- 坐标系转换：世界坐标 ↔ 炮管坐标
- 粒子系统：生成、更新、渲染、清理
- 动画帧管理和性能优化

**设计亮点**：
1. **物理真实性**：引信摆动采用真实物理算法
2. **视觉统一性**：火炮主题贯穿（石座→金属炮管→引信→火球→爆炸）
3. **细节打磨**：5层视觉效果叠加（绳子→发光→亮核→火焰→火花）
4. **性能平衡**：精致效果与流畅运行的完美平衡

---

## 📚 教育价值设计

### 学习目标

1. **拼写能力**：通过填补缺失字母提高拼写准确性
2. **词汇记忆**：在游戏压力下加深单词印象
3. **反应速度**：提高英语思维的快速反应能力
4. **语音意识**：通过字母组合理解发音规律
5. **听力训练**：通过持续的单词朗读，建立单词发音与拼写的关联，培养听音辨词能力
6. **标准发音学习**：接触标准英式发音，培养正确的发音习惯
7. **词义理解**：通过爆炸时显示的中文翻译，强化英文单词与中文意思的关联记忆
8. **重音学习**：通过重音音节的红色高亮，帮助学生识别和记忆单词的正确重音位置，提升口语发音准确性

### 词汇库设计

- **分级词汇**：根据小学 6 年级英语课程标准
- **主题分类**：动物、颜色、家庭、学校、食物等
- **难度递进**：从常见词汇到复杂词汇
- **音标关联**：结合项目中的音标学习材料

### 学习反馈机制

- **实时反馈**：每次按键都有即时的视觉反馈，正确字母绿色高亮并放大，错误字母红色闪烁
- **成功奖励反馈**：射击成功时的中文翻译爆炸效果，强化词义记忆
- **学习报告**：游戏结束后显示学习统计
- **生词本系统**：
  - 自动收集堆叠区中的放弃或失败单词
  - 成功射击的单词不进入生词本（表示已掌握）
  - **升级时保留生词本**：升级时生词本不清空，持续累积
  - **重置时清空生词本**：只有重置游戏时才清空生词本和统计数据
  - 提供生词本复习模式和测试功能
- **考试统计系统**：
  - **考试总词量**：显示单词库中的总单词数（135个）
  - **正确命中**：显示成功射击的不重复单词数量
  - **命中率**：正确命中单词数 / 考试总词量 × 100%
  - **覆盖率**：与命中率相同，表示对单词库的掌握程度
  - **去重统计**：同一单词多次命中只计算一次
  - **实时更新**：每次成功射击后立即更新统计显示
  - 记录每个生词的放弃次数和掌握程度
- **错误回顾**：记录错误单词，提供复习机会
- **进度追踪**：长期学习进度的可视化展示

---

## 🛠️ 技术实现方案

### 开发平台选择

**推荐方案：Web-based 游戏**

- **前端**：HTML5 Canvas + JavaScript
- **框架**：Phaser.js 或 PixiJS
- **优势**：跨平台、易部署、易更新

**备选方案：移动应用**

- **框架**：React Native 或 Flutter
- **优势**：更好的移动体验、离线功能

### 核心功能模块

1. **游戏引擎模块**

   - 单词顺序下降控制（单个单词机制）
   - **缓冲区信号灯系统**：确保红 → 黄 → 绿灯各亮 1 秒，绿灯必须完整显示
   - 堆叠区管理（专门存放失败单词）
   - 实时输入处理与自动射击判定
   - **炮管射击系统**：炮弹轨迹计算与动画
   - **错误处理系统**：红叉显示与输入清空逻辑
   - "放弃"按键处理
   - **爆炸特效系统**：粒子效果与单词消失动画
   - **语音朗读系统**：单词下降时的英式发音播放与定时重复机制
   - 分数计算与正确性评估
   - 等级转换逻辑
   - **游戏重置系统**：
     - 页面刷新自动重置：加载时自动清空所有数据
     - 手动重置自动开始：点击重置按钮后自动开始游戏
     - 重置类型区分：不同触发方式的不同后续行为

2. **分布式词汇管理模块**

   - **词库架构设计**：
     - 配置文件管理：config.json统一管理词库元数据
     - 分布式存储：按主题拆分词库文件（basic-phonics.json、special-phonics.json等）
     - 动态加载机制：按需加载用户选择的词库文件
   - **VocabularyManagerV2**：
     - 异步加载系统：并行加载多个词库文件
     - 配置管理：支持用户自定义词库选择和高级设置
     - 本地存储：用户设置持久化保存
     - 兼容性保证：保持与原有游戏逻辑的完全兼容
     - **重音识别系统**：
       - 从音标中识别重音符号（ˈ 主重音，ˌ 次重音）
       - 计算重音音节在单词中的位置
       - 音节边界识别算法
       - 生成重音字母位置数组
   - 难度分级和随机选择算法
   - 字母缺失算法
   - **中文翻译管理**：每个英文单词对应准确的中文翻译

2.5. **单词图片展示模块**（新增）

   - **图片管理器（WordImageManager）**：
     - 图片来源管理：本地图片库 → Unsplash API → 图标字体 → 占位符
     - 降级策略：自动尝试多个图片源，确保始终有图片显示
     - 缓存管理：localStorage 缓存图片 URL，7 天过期
     - 预加载机制：当前单词加载完成后预加载下一个单词
   
   - **图片加载器（ImageLoader）**：
     - 异步加载：Promise-based 图片加载
     - 超时控制：5 秒超时，自动降级
     - 重试机制：失败后最多重试 3 次
     - 错误处理：优雅降级，不影响游戏进行
   
   - **图片渲染器（ImageRenderer）**：
     - DOM 渲染：使用 HTML/CSS 而非 Canvas（更灵活）
     - 动画控制：CSS 动画 + JavaScript 触发
     - 特效系统：成功闪烁、错误抖动、切换滑动
     - 响应式布局：自适应不同屏幕尺寸
   
   - **占位符生成器（PlaceholderGenerator）**：
     - 渐变背景：根据单词首字母生成不同颜色
     - 首字母显示：超大号白色字母
     - 图标字体集成：Font Awesome 图标作为降级方案
     - 美观设计：即使是占位符也要有良好视觉效果
   
   - **图片缓存系统（ImageCache）**：
     - 缓存键管理：`wordImage_{word}` 格式
     - 过期检查：7 天自动过期
     - 容量限制：最多缓存 100 个单词图片
     - 清理机制：LRU（最近最少使用）算法
   
   - **与游戏引擎集成**：
     - 单词切换时自动更新图片
     - 射击成功时触发绿色闪烁特效
     - 错误输入时触发抖动特效
     - 游戏暂停时停止图片加载

3. **界面渲染模块**

   - Canvas 绘制
   - **炮管渲染**：炮管位置、瞄准方向显示
   - **炮弹轨迹渲染**：射击时的光束效果
   - **粒子系统**：爆炸特效的粒子动画
   - **中文翻译渲染**：爆炸时中文翻译的放大动画效果
   - **字体大小控制**：
     - 主要单词显示：32px字体（从20px增加，提升60%可见性）
     - 缓冲区单词显示：28px字体（从24px增加，提升17%可见性）
     - 输入字母放大显示：1.2-1.5倍大小
   - **单词大小写控制**：所有单词统一使用小写字母显示，提升阅读体验
   - **输入字母小写化**：用户输入以小写形式显示，验证时转为大写比较
   - **重音音节高亮渲染**：
     - 根据音标识别重音位置
     - 重音音节字母用红色显示（#ff4444）
     - 与用户输入高亮区分优先级
     - 单音节词不高亮
   - **错误标记渲染**：血色红叉的显示与动画
   - 实时输入反馈动画
   - 单词下沉到堆叠区动画
   - 用户界面
   - 响应式设计
   - 堆叠区可视化（失败单词存储）

4. **生词本管理模块**

   - 生词自动收集
   - **生词本总数显示**：标题动态显示当前生词数量"生词本 (数量)"
   - 生词本生成
   - 掌握度统计
   - **简化导出功能**：导出为文本格式"单词, 音标, 中文翻译"
   - **清空逻辑优化**：
     - 升级时保留生词本（持续累积）
     - 重置时清空生词本（完全重新开始）

5. **语音朗读模块**

   - **TTS 引擎集成**：多提供商降级机制
     - **iOS 设备**：优先使用 Web Speech API（浏览器原生，无播放限制）
     - **非 iOS 设备**：优先使用第三方 TTS 服务（音质更好）
       - 百度翻译 TTS（国内稳定）
       - 有道智云 TTS（国内稳定）
       - 微软 Bing TTS（备用）
       - Web Speech API（最终降级方案）
   
   - **iOS 兼容性优化**：
     - **自动设备检测**：通过 User Agent 检测 iOS 设备
     - **提供商优先级调整**：
       - iOS：Web Speech API > 有道 TTS > 百度 TTS
       - 其他：百度 TTS > 有道 TTS > Bing TTS > Web Speech API
     - **音频上下文激活**：
       - iOS 设备：游戏开始时激活 Web Speech API（无需复杂解锁）
       - 非 iOS 设备：跳过 iOS 特定的音频解锁逻辑
       - 仅在用户交互时（点击、按键）激活
     - **错误处理优化**：
       - iOS 设备的 Audio 播放失败视为正常（已使用 Web Speech API）
       - 自动降级到下一个可用提供商
   
   - **英式发音配置**：设置语音为英式英语（en-GB）
     - Web Speech API：自动选择英式语音（Google UK English Female/Male）
     - 第三方 TTS：通过 URL 参数指定英式发音
   
   - **语音缓存系统**：双模式存储（本地开发 + Vercel部署）
     
     **核心功能**：
     - **自动缓存**：首次播放单词时下载音频并缓存，后续播放直接使用缓存
     - **持久化存储**：关闭网页、刷新页面、部署新版本后缓存依然存在
     - **双模式存储**：
       - 本地开发：优先使用 `proj/audio/` 目录的 MP3 文件
       - Vercel部署：自动使用浏览器 IndexedDB 存储
     - **文件命名规范**：`{word}_{provider}.mp3`（如 `hello_baidu.mp3`）
     
     **本地开发环境**：
     - **检查顺序**：
       1. 本地文件（`proj/audio/`）→ 直接播放
       2. 无本地文件 → 在线下载 → 提示保存到本地
     - **保存流程**：
       1. 游戏播放单词时自动下载音频
       2. 控制台执行 `downloadLocalAudio()` 批量下载
       3. 手动保存到 `proj/audio/` 目录
       4. 通过 git 提交到代码库
     - **优势**：
       - 可通过 git 管理音频文件
       - 部署到 Vercel 后自动可用
       - 减少在线TTS请求次数
     
     **Vercel生产环境**：
     - **检查顺序**：
       1. 本地文件（`proj/audio/`，如果有）→ 直接播放
       2. IndexedDB 缓存 → 直接播放
       3. 无缓存 → 在线下载 → 自动保存到 IndexedDB → 播放
     - **自动缓存**：
       - 首次播放：下载 + 保存到 IndexedDB（异步）
       - 后续播放：直接从 IndexedDB 读取（秒开）
     - **持久化**：
       - 关闭网页后缓存依然存在
       - 刷新页面后直接使用缓存
       - 部署新版本后缓存不丢失
     - **优势**：
       - 用户首次访问后自动建立缓存
       - 多次访问越来越快
       - 减少网络流量和TTS服务压力
     
     **IndexedDB 技术细节**：
     - **数据库名**：`WordTetrisAudioCache`
     - **对象存储**：`audios`
     - **复合索引**：`word_provider`（word + provider）
     - **数据结构**：
       ```javascript
       {
         id: 1,                    // 自增主键
         word: "hello",            // 单词（小写）
         provider: "baidu",        // 提供商（小写）
         blob: Blob,               // 音频二进制数据
         timestamp: 1696780800000  // 保存时间戳
       }
       ```
     - **存储容量**：通常 50MB - 数GB（取决于浏览器）
     - **浏览器支持**：Chrome、Edge、Firefox、Safari（包括iOS）
     
     **缓存管理 API**：
     - **查看缓存统计**：
       ```javascript
       const cacheManager = AudioCacheManager.getInstance();
       const stats = await cacheManager.getStats();
       console.log(stats); // { total: 25, totalSizeMB: "0.49", items: [...] }
       ```
     - **清空缓存**：
       ```javascript
       await cacheManager.clearAllCache();
       ```
     - **批量下载（本地开发）**：
       ```javascript
       downloadLocalAudio(); // 下载所有待保存的音频
       ```
     
     **错误降级策略**：
     - IndexedDB 初始化失败 → 降级到在线模式
     - 本地文件读取失败 → 检查 IndexedDB
     - IndexedDB 读取失败 → 在线下载
     - 缓存保存失败 → 不影响播放，静默处理
     
     **性能优化**：
     - 异步保存：下载后立即播放，保存操作异步进行
     - 内存缓存：已使用的 Blob URL 缓存到内存，避免重复创建
     - 资源释放：播放完成后释放 Blob URL，防止内存泄漏
     - 并发下载：多个单词可同时下载（受浏览器限制）
     
     **技术实现细节**：
     
     **(1) AudioCacheManager 类设计**：
     ```javascript
     class AudioCacheManager {
       // 核心属性
       dbName: "WordTetrisAudioCache"
       dbVersion: 1
       storeName: "audios"
       db: IDBDatabase
       isLocal: boolean  // 环境检测结果
       blobUrlCache: Map // 内存缓存
       
       // 核心方法
       async initialize()                          // 初始化 IndexedDB
       async hasCache(word, provider)              // 检查缓存是否存在
       async getCache(word, provider)              // 获取缓存音频（返回 Blob URL）
       async saveCache(word, provider, audioBlob)  // 保存缓存
       async downloadAudio(url)                    // 下载在线音频为 Blob
       isLocalDevelopment()                        // 环境检测
       async checkLocalFile(word, provider)        // 检查本地文件
       getLocalFilePath(word, provider)            // 获取本地文件路径
       async getStats()                            // 获取缓存统计
       async clearAllCache()                       // 清空所有缓存
       clearBlobUrlCache()                         // 清理内存缓存
     }
     ```
     
     **(2) IndexedDB 数据结构**：
     ```javascript
     数据库名: "WordTetrisAudioCache"
     版本: 1
     对象存储: "audios"
     主键: id (自增)
     复合索引: word_provider (word + provider, unique)
     时间戳索引: timestamp (用于清理旧缓存)
     
     数据记录:
     {
       id: 1,                    // 自增主键
       word: "hello",            // 单词（小写）
       provider: "baidu",        // 提供商（小写）
       blob: Blob,               // 音频二进制数据
       timestamp: 1696780800000  // 保存时间戳
     }
     ```
     
     **(3) TTSService 集成改造**：
     
     **构造函数新增**：
     ```javascript
     this.cacheManager = null;      // 延迟初始化
     this.cacheEnabled = true;      // 是否启用缓存
     ```
     
     **initialize() 方法改造**：
     ```javascript
     async initialize() {
       // 1. 初始化缓存管理器
       if (!this.cacheManager && this.cacheEnabled) {
         this.cacheManager = AudioCacheManager.getInstance();
         await this.cacheManager.initialize();
       }
       
       // 2. 原有的 TTS 提供商测试逻辑
       // ...
     }
     ```
     
     **_speakWithAudioURL() 方法改造**：
     ```javascript
     async _speakWithAudioURL(url, providerName, volume, word) {
       // 如果启用缓存且提供了单词
       if (this.cacheEnabled && this.cacheManager && word) {
         const providerKey = this._getProviderKey(providerName);
         
         // 1. 检查缓存
         if (await this.cacheManager.hasCache(word, providerKey)) {
           const cachedUrl = await this.cacheManager.getCache(word, providerKey);
           return await this._playAudio(cachedUrl, volume, providerName);
         }
         
         // 2. 下载音频
         const audioBlob = await this.cacheManager.downloadAudio(url);
         
         // 3. 保存缓存（异步，不阻塞播放）
         this.cacheManager.saveCache(word, providerKey, audioBlob);
         
         // 4. 播放
         const blobUrl = URL.createObjectURL(audioBlob);
         return await this._playAudio(blobUrl, volume, providerName);
       }
       
       // 未启用缓存，直接播放
       return await this._playAudio(url, volume, providerName);
     }
     ```
     
     **新增辅助方法**：
     ```javascript
     _getProviderKey(providerName) {
       if (providerName.includes('百度')) return 'baidu';
       if (providerName.includes('有道')) return 'youdao';
       if (providerName.includes('Bing')) return 'bing';
       return 'unknown';
     }
     
     _playAudio(audioUrl, volume, providerName) {
       return new Promise((resolve, reject) => {
         const audio = new Audio(audioUrl);
         audio.volume = volume;
         
         audio.onended = () => {
           // 释放 Blob URL
           if (audioUrl.startsWith('blob:')) {
             URL.revokeObjectURL(audioUrl);
           }
           resolve();
         };
         
         // ... 其他事件处理
       });
     }
     ```
     
     **提供商配置修改**（所有提供商）：
     ```javascript
     speak: (word, volume = 1.0) => this._speakWithAudioURL(
       url,
       providerName,
       volume,
       word  // ← 新增：传递单词用于缓存
     )
     ```
     
     **(4) 缓存检查流程**：
     ```
     播放单词
       ↓
     1. 检查本地文件 (proj/audio/{word}_{provider}.mp3)
       ↓ 存在 → 直接播放
       ↓ 不存在
     2. 检查 IndexedDB (word + provider 复合索引查询)
       ↓ 存在 → 创建 Blob URL → 播放
       ↓ 不存在
     3. 在线下载 (fetch TTS URL)
       ↓
     4. 保存缓存
       - 本地开发：提示下载文件（console + downloadLocalAudio()）
       - Vercel部署：自动保存到 IndexedDB（异步）
       ↓
     5. 创建 Blob URL
       ↓
     6. 播放音频
       ↓
     7. 播放完成后释放 Blob URL
     ```
     
     **(5) 环境检测逻辑**：
     ```javascript
     isLocalDevelopment() {
       const hostname = location.hostname;
       return hostname === 'localhost' || 
              hostname === '127.0.0.1' || 
              hostname === '' ||
              hostname.startsWith('192.168.') ||  // 局域网
              hostname.startsWith('10.');         // 局域网
     }
     ```
     
     **(6) 本地文件下载机制**（本地开发环境）：
     ```javascript
     // 全局下载队列
     window._audioCacheDownloadQueue = [];
     
     // 添加到下载队列
     _promptDownloadFile(word, provider, audioBlob) {
       const fileName = `${word.toLowerCase()}_${provider.toLowerCase()}.mp3`;
       
       window._audioCacheDownloadQueue.push({
         word,
         provider,
         blob: audioBlob,
         fileName
       });
       
       console.log(`💡 建议下载文件: ${fileName}`);
       console.log(`   保存到: proj/audio/${fileName}`);
     }
     
     // 全局批量下载函数
     window.downloadLocalAudio = () => {
       const queue = window._audioCacheDownloadQueue || [];
       queue.forEach((item, index) => {
         setTimeout(() => {
           const url = URL.createObjectURL(item.blob);
           const a = document.createElement('a');
           a.href = url;
           a.download = item.fileName;
           a.click();
           URL.revokeObjectURL(url);
         }, index * 500); // 间隔500ms，避免浏览器阻止
       });
       window._audioCacheDownloadQueue = [];
     };
     ```
     
     **(7) Blob URL 内存管理**：
     ```javascript
     // 内存缓存
     this.blobUrlCache = new Map(); // key: "word_provider", value: blobUrl
     
     // 获取缓存时先检查内存
     async getCache(word, provider) {
       const cacheKey = `${word}_${provider}`;
       
       // 1. 检查内存缓存
       if (this.blobUrlCache.has(cacheKey)) {
         return this.blobUrlCache.get(cacheKey);
       }
       
       // 2. 检查本地文件
       // 3. 检查 IndexedDB
       // ...
       
       // 缓存到内存
       this.blobUrlCache.set(cacheKey, blobUrl);
       return blobUrl;
     }
     
     // 清理内存缓存
     clearBlobUrlCache() {
       this.blobUrlCache.forEach(blobUrl => {
         URL.revokeObjectURL(blobUrl);
       });
       this.blobUrlCache.clear();
     }
     ```
     
     **(8) 错误降级策略**：
     ```javascript
     // 缓存操作失败不影响播放
     try {
       // 尝试使用缓存
       if (await this.cacheManager.hasCache(word, provider)) {
         return await this._playAudio(cachedUrl, volume);
       }
       
       // 尝试下载并缓存
       const audioBlob = await this.cacheManager.downloadAudio(url);
       this.cacheManager.saveCache(word, provider, audioBlob); // 异步，不等待
       return await this._playAudio(blobUrl, volume);
       
     } catch (error) {
       // 降级到直接播放在线 URL
       console.warn('缓存操作失败，降级到在线播放');
       return await this._playAudio(url, volume);
     }
     ```
     
     **(9) 文件命名规范**：
     ```
     格式: {word}_{provider}.mp3
     规则:
     - word: 全部小写
     - provider: 全部小写（baidu/youdao/bing）
     - 扩展名: .mp3
     
     示例:
     ✅ hello_baidu.mp3
     ✅ world_youdao.mp3
     ✅ good_bing.mp3
     
     ❌ Hello_Baidu.mp3  (大写)
     ❌ hello-baidu.mp3  (连字符)
     ❌ hello_baidu.wav  (错误格式)
     ```
     
     **(10) 测试验证要点**：
     
     **本地开发测试**：
     - 首次播放单词，控制台提示可以下载
     - 执行 `downloadLocalAudio()` 后浏览器提示下载
     - 将文件保存到 `proj/audio/` 目录
     - 第二次播放使用本地文件（控制台显示"使用本地文件"）
     - 文件可以通过 `git add proj/audio/*.mp3` 提交
     
     **Vercel部署测试**：
     - 首次播放单词自动缓存到 IndexedDB（控制台显示"保存到 IndexedDB"）
     - 刷新页面后直接使用 IndexedDB 缓存（控制台显示"从 IndexedDB 读取"）
     - 关闭浏览器重新打开后缓存依然存在
     - 部署新版本后缓存不丢失（验证方法：更新代码版本后刷新页面，缓存依然可用）
     
     **跨浏览器测试**：
     - Chrome/Edge：完整支持（推荐）
     - Firefox：完整支持
     - Safari（macOS）：完整支持
     - Safari（iOS）：完整支持（使用 Web Speech API 优先）
   
   - **游戏模式差异化播放策略**：
     
     **😊 休闲模式（Casual Mode）**：
     - **初次播放延迟**：单词开始下降后，延迟 2 秒播放第一次音频
     - **重复播放间隔**：每 5 秒重复播放一次
     - **播放停止时机**：
       - 单词被停止（调用 `stopSpeaking()`）
       - 清除首次播放定时器（2秒延迟）
       - 清除重复播放定时器（5秒间隔）
     - **设计理念**：给学生充足的思考时间，降低焦虑感
     
    **🔥 挑战模式（Challenge Mode）**：
    - **缓冲区倒数播放**：单词在缓冲区**开始倒数时**（红灯亮起时）立即播放第一次音频
    - **播放时机优化**：音频播放与倒数同步开始（红灯→黄灯→绿灯）
    - **下降时播放策略**：
      - 单词开始下降时，**不立即播放**（避免与缓冲区播放冲突）
      - 仅设置 5 秒重复播放定时器
      - 如果缓冲区播放成功，5秒后进行第一次重复
      - 如果缓冲区播放失败，立即进行第一次播放，并设置 5 秒重复播放
    - **重复播放间隔**：每 5 秒重复播放一次
    - **播放失败重试**：
      - 播放失败后立即尝试下一个 TTS 提供商
      - 不等待 5 秒，直接重试
    - **设计理念**：提前播放增强记忆压力，模拟考试环境
   
   - **播放超时控制**：
     - **统一超时时间**：所有模式使用 3 秒超时限制
     - **超时计算方式**：每个 TTS 提供商独立计时
     - **超时处理**：
       - 单个提供商超时后，自动尝试下一个，并降低该提供商的优先级（也就是移动到队列尾部）
       - 记录失败次数，3 次失败后自动移除该提供商
       - 超时不影响游戏进行，静默处理
   
   - **取消令牌系统**：
     - **设计原因**：解决多个播放请求并发时的取消冲突
     - **实现机制**：
       - 为每个 `speak()` 调用分配唯一 ID（单调递增）
       - 使用 ID 集合追踪活跃和已取消的调用
       - 独立检查每个调用的取消状态
     - **ID 管理**：
       - `currentSpeakId`：计数器，分配唯一 ID
       - `activeSpeakIds`：Set，存储当前活跃的调用 ID
       - `cancelledSpeakIds`：Set，存储已取消的调用 ID
     - **溢出保护**：
       - 检测 ID 接近 `Number.MAX_SAFE_INTEGER`（9千万亿）
       - 自动重置计数器并清理取消记录
       - 实际使用中几乎不可能触发（需要连续运行 1644 万年）
     - **取消逻辑**：
       - 外部取消（单词失败、暂停）：标记所有活跃 ID 为已取消
       - 内部清理（提供商失败）：仅清理资源，不取消其他尝试
       - 取消检查：在循环开始和 Promise 完成后检查
     - **内存管理**：
       - ID 使用后立即从集合中删除
       - 重置时清空所有集合
       - 防止内存泄漏
   
   - **游戏状态检查**：
     - **播放前检查**：`speakWord()` 方法检查 `gameState`
     - **允许播放状态**：仅在 `gameState === 'playing'` 时播放
     - **阻止播放场景**：
       - 游戏暂停（`paused`）
       - 游戏结束（`gameOver`）
       - 游戏停止（`stopped`）
       - 升级过渡（`levelup`）
     - **设计目的**：防止游戏暂停后音频继续播放
   
   - **朗读停止条件**：
     - 单词被成功射击击落时停止
     - 单词被放入堆叠区时停止
     - 游戏暂停时停止
     - 清除所有定时器（首次播放、重复播放）
     - 调用 `TTSService.stop()` 停止当前音频
   
   - **错误处理与日志**：
     - **错误分类**：
       - 🚫 浏览器限制（NotAllowedError）
       - 🍎 iOS 设备限制（Audio 对象限制）
       - ⏱️ TTS 服务超时（3秒限制）
       - 🌐 网络问题（加载失败、403、404）
       - ⚠️ 播放被中断（正常现象，不计入失败）
     - **日志级别**：
       - `info`（白色）：正常操作、播放中断
       - `warning`（黄色）：真正的错误、提供商失败
       - `error`（红色）：所有提供商不可用
     - **详细信息**：
       - 显示单词、提供商名称、失败序号
       - 显示播放开始时间、用时、超时限制
       - 显示错误类型、原因、解决建议
       - 显示调用堆栈（调试用）
   
   - **音量控制**：提供音量调节和静音选项
   
   - **降级方案**：
     - 提供商失败时自动切换到下一个
     - 所有提供商失败时静默处理（不影响游戏）
     - 连续失败 3 次的提供商自动移除
     - 自动重新初始化并重试

6. **数据存储模块**
   - 游戏进度保存
   - 生词本数据
   - 学习统计
   - 设置保存（包括音量和语音设置）
   - 离线数据同步

7. **考试统计模块**
   - **命中单词跟踪**：使用Set数据结构存储已命中的单词（去重）
   - **下落单词跟踪**：使用Set数据结构存储所有下落过的单词（去重）
   - **双重统计计算**：
     - 命中率：命中单词数 ÷ 下落单词数 × 100%（反映游戏表现）
     - 覆盖率：命中单词数 ÷ 总单词库数量 × 100%（反映学习进度）
   - **统计显示更新**：每次射击成功后更新UI显示
   - **数据持久化**：统计数据随游戏进度保存
   - **重置机制**：重置游戏时清空所有统计数据

8. **词库设置管理模块**
   - **设置界面系统**：
     - 词库选择界面：可视化展示所有可用词库
     - 词库卡片设计：显示名称、描述、单词数、难度、推荐状态
     - 切换控制：支持启用/禁用词库的直观切换
   - **配置管理系统**：
     - 实时配置更新：设置变更立即生效
     - 本地存储：用户偏好设置持久化保存
     - 默认配置：提供合理的默认词库组合
     - 配置验证：确保至少启用一个词库
   - **高级设置选项**：
     - 最大单词数量：控制游戏中使用的单词总数
     - 难度范围：设置允许的单词难度范围
     - 分类筛选：按词库分类进行筛选
   - **统计预览功能**：
     - 实时统计：显示当前配置下的总单词数
     - 词库分布：展示各词库的单词数量分布
     - 难度分析：显示不同难度级别的单词分布

### 性能优化考虑

- **内存管理**：及时清理已击落的单词对象
- **渲染优化**：使用对象池减少 GC 压力
- **资源加载**：预加载常用资源，懒加载高级内容
- **响应性**：确保 60FPS 的流畅体验

---

## 🎮 游戏功能扩展

### 基础功能

- [x] 单词下降机制
- [x] 字母填空玩法
- [x] 分数与等级系统
- [x] 缓冲区机制

### 进阶功能

- [ ] **生词本复习**：专门的生词复习模式
- [ ] **生词本测试**：基于生词本的专项测试
- [ ] **多人模式**：与同学竞赛或合作
- [ ] **主题模式**：专门练习某类词汇
- [ ] **时间挑战**：限时模式增加紧张感
- [ ] **音标模式**：结合音标学习的特殊模式
- [ ] **生词导出**：将生词本导出为学习卡片

### 高级功能

- [ ] **AI 助手**：智能提示和学习建议
- [ ] **语音识别**：说出单词而非打字
- [ ] **AR 模式**：增强现实的沉浸式体验
- [ ] **社交功能**：分享成绩、挑战好友

---

## 📈 商业化与推广

### 盈利模式

1. **免费增值**：基础功能免费，高级功能付费
2. **教育授权**：向学校和教育机构授权
3. **内容订阅**：定期更新词汇包和主题
4. **广告收入**：适度的教育相关广告

### 推广策略

1. **教育渠道**：与学校和培训机构合作
2. **家长社群**：在家长群体中推广
3. **应用商店**：ASO 优化，获得推荐位
4. **社交媒体**：制作游戏视频和教程

---

## 🚀 开发时间线

### 第一阶段：原型开发（4-6 周）

- 基础游戏机制实现
- 简单 UI 界面
- 核心玩法验证
- 小规模用户测试

### 第二阶段：功能完善（6-8 周）

- 完整 UI/UX 设计
- 音效和动画
- 数据存储系统
- 多设备适配

### 第三阶段：内容制作（4-6 周）

- 词汇库建设
- 关卡设计
- 教学内容整合
- 测试和优化

### 第四阶段：发布准备（2-4 周）

- 最终测试
- 性能优化
- 发布准备
- 营销材料制作

---

## 💡 创新亮点

### 教育游戏化

- **寓教于乐**：在游戏中自然学习，避免枯燥记忆
- **即时反馈**：立即知道对错，加强学习效果
- **进度可视**：清晰的进步轨迹，增强学习动机

### 技术创新

- **智能难度调节**：根据玩家表现动态调整难度
- **个性化学习**：记录学习偏好，推荐合适内容
- **跨平台同步**：多设备学习进度同步

### 用户体验

- **简单易学**：游戏规则简单，上手容易
- **高度沉浸**：紧张刺激的游戏节奏
- **成就感强**：清晰的进步反馈和奖励机制
- **视觉友好**：使用小写字母显示，符合阅读习惯，降低视觉压迫感

---

## 📋 风险评估与应对

### 技术风险

- **性能问题**：单词渲染和动画效果可能影响性能
  - _应对_：优化渲染算法，使用对象池
- **兼容性问题**：不同设备的适配问题
  - _应对_：充分测试，响应式设计

### 教育风险

- **学习效果**：游戏性可能影响学习专注度
  - _应对_：平衡游戏性和教育性，定期评估
- **内容质量**：词汇选择可能不够科学
  - _应对_：与教育专家合作，基于课程标准

### 市场风险

- **竞争激烈**：教育游戏市场竞争激烈
  - _应对_：突出特色，专注细分市场
- **用户获取**：获取目标用户可能困难
  - _应对_：多渠道推广，重视口碑营销

---

## 🎯 成功指标

### 用户指标

- **日活跃用户**：目标 1000+
- **用户留存率**：7 日留存>30%
- **平均游戏时长**：15-20 分钟/次

### 学习效果指标

- **词汇掌握率**：游戏中练习的单词掌握率>80%
- **拼写准确率**：相比游戏前提升>20%
- **学习兴趣**：用户满意度>4.5/5.0

### 商业指标

- **用户获取成本**：<$5/用户
- **付费转化率**：>5%
- **月收入**：目标$10,000+

---

## 📞 下一步行动

### 即时行动

1. **用户调研**：与目标用户群体深度访谈
2. **技术验证**：制作简单原型验证核心机制
3. **竞品分析**：研究现有教育游戏的优缺点
4. **团队组建**：招募或联系开发团队成员

### 短期计划

1. **详细设计**：完善游戏设计文档
2. **技术选型**：确定开发技术栈
3. **资源准备**：准备开发所需资源
4. **合作洽谈**：与教育机构初步接触

---

## 📝 设计更新日志

### 2025-10-08 更新 v13
- **语音缓存系统实现**：双模式存储（本地开发 + Vercel部署）
  
  **🎯 核心功能**：
  
  1. **自动音频缓存**：
     - 首次播放单词时自动下载 TTS 音频并缓存
     - 后续播放直接使用缓存，无需重新下载
     - 支持多个 TTS 提供商独立缓存（baidu/youdao/bing）
  
  2. **本地开发环境**：
     - 优先使用 `proj/audio/` 目录的 MP3 文件
     - 无缓存时自动下载音频并提示保存
     - 控制台执行 `downloadLocalAudio()` 批量下载
     - 手动保存到本地目录后可通过 git 提交
     - 文件命名：`{word}_{provider}.mp3`（如 `hello_baidu.mp3`）
  
  3. **Vercel 生产环境**：
     - 自动使用浏览器 IndexedDB 持久化存储
     - 首次播放下载并保存到 IndexedDB
     - 后续访问直接从 IndexedDB 读取（秒开）
     - 关闭网页、刷新页面、部署新版本后缓存不丢失
     - 支持 Chrome、Edge、Firefox、Safari（包括 iOS）
  
  4. **IndexedDB 技术实现**：
     - 数据库名：`WordTetrisAudioCache`
     - 对象存储：`audios`（自增主键）
     - 复合索引：`word_provider`（快速查询）
     - 数据结构：`{ word, provider, blob, timestamp }`
     - 存储容量：50MB - 数GB（取决于浏览器）
  
  5. **性能优化**：
     - 异步保存：下载后立即播放，保存操作不阻塞
     - 内存缓存：已使用的 Blob URL 缓存到内存
     - 资源释放：播放完成后自动释放 Blob URL
     - 错误降级：缓存失败时降级到在线播放
  
  6. **缓存管理 API**：
     - `getStats()`：查看缓存统计（数量、大小、详情）
     - `clearAllCache()`：清空所有缓存
     - `downloadLocalAudio()`：批量下载音频文件（本地开发）
  
  **📁 新增文件**：
  - `proj/src/utils/AudioCacheManager.js`：音频缓存管理器
  - `proj/audio/.gitkeep`：空目录占位
  - `proj/audio/README.md`：使用说明
  
  **🔧 修改文件**：
  - `proj/src/utils/TTSService.js`：
    - 集成 AudioCacheManager
    - 修改 `_speakWithAudioURL()` 支持缓存
    - 新增 `_getProviderKey()` 提取提供商简称
    - 新增 `_playAudio()` 统一播放逻辑
    - 所有提供商的 `speak` 函数传递 word 参数
  - `proj/index.html`：加载 AudioCacheManager.js
  - `word_tetris_game_design.md`：添加语音缓存系统文档
  
  **✅ 验证要点**：
  - 本地开发：首次播放提示下载，执行 `downloadLocalAudio()` 保存文件
  - Vercel部署：首次播放自动缓存，刷新页面后直接使用缓存
  - 跨浏览器：Chrome/Edge/Firefox/Safari 均支持 IndexedDB
  - git 提交：`proj/audio/` 目录的 MP3 文件可提交到代码库

### 2025-10-08 更新 v12
- **音频播放系统全面优化**：解决播放冲突、取消逻辑、游戏状态联动等核心问题
  
  **🎯 核心问题修复**：
  
  1. **游戏模式差异化播放策略**：
     - **休闲模式**：
       - 单词开始下降后延迟 2 秒播放第一次
       - 每 5 秒重复播放
       - 给学生充足思考时间
    - **挑战模式**：
      - 单词在缓冲区**开始倒数时**（红灯亮起时）立即播放
      - 下降时仅设置 5 秒重复定时器（避免播放冲突）
      - 提前播放增强记忆压力
  
  2. **取消令牌系统（Cancel Token）**：
     - **问题**：多个 `speak()` 调用共享全局 `isCancelled` 标志，导致取消冲突
     - **解决方案**：
       - 为每个 `speak()` 调用分配唯一 ID（单调递增）
       - 使用 `activeSpeakIds` Set 追踪活跃调用
       - 使用 `cancelledSpeakIds` Set 追踪已取消调用
       - 独立检查每个调用的取消状态
     - **溢出保护**：
       - 检测 ID 接近 `Number.MAX_SAFE_INTEGER`（9千万亿）
       - 自动重置计数器，实际永远不会触发
     - **内存管理**：
       - 调用完成后立即删除 ID
       - 防止内存泄漏
  
  3. **`stop()` 方法优化**：
     - **参数化控制**：添加 `setCancelled` 参数（默认 `true`）
     - **区分场景**：
       - `stop(true)`：外部主动取消（单词失败、暂停）→ 标记所有活跃调用为已取消
       - `stop(false)`：内部清理资源（提供商失败）→ 仅清理，允许继续尝试其他提供商
     - **调用堆栈追踪**：日志显示 `stop()` 调用来源，便于调试
  
  4. **游戏状态联动检查**：
     - **播放前检查**：`speakWord()` 检查 `gameState`
     - **允许播放**：仅在 `gameState === 'playing'` 时播放
     - **阻止场景**：暂停、结束、停止、升级过渡时不播放
     - **解决问题**：防止游戏暂停后音频继续播放
  
  5. **iOS 设备检测优化**：
     - **自动检测**：通过 `navigator.userAgent` 检测 iOS 设备
     - **条件执行**：iOS 音频解锁逻辑仅在 iOS 设备上运行
     - **跳过非 iOS**：非 iOS 设备跳过 iOS 特定逻辑
  
  6. **超时控制优化**：
     - **统一超时**：所有模式使用 3 秒超时（从 1 秒 → 2 秒 → 3 秒演进）
     - **独立计时**：每个 TTS 提供商独立计时
     - **超时处理**：超时后自动尝试下一个提供商
  
  7. **错误处理与日志优化**：
     - **错误分类**：
       - 🚫 浏览器限制（NotAllowedError）
       - 🍎 iOS 设备限制（Audio 对象限制）
       - ⏱️ TTS 服务超时（3秒限制）
       - 🌐 网络问题（加载失败、403、404）
       - ⚠️ 播放被中断（正常现象，不计入失败）
     - **日志级别优化**：
       - `info`（白色）：正常操作、播放中断
       - `warning`（黄色）：真正的错误、提供商失败
       - `error`（红色）：所有提供商不可用
     - **详细信息增强**：
       - 显示单词、提供商名称、失败序号
       - 显示播放开始时间、实际用时、超时限制
       - 显示错误类型、原因、解决建议
       - 显示调用堆栈（调试用）
       - 显示取消令牌 ID（调试用）
  
  **🎨 实现细节**：
  - **文件修改**：
    - `proj/src/core/WordTetrisGame.js`：游戏逻辑、模式差异化、状态检查
    - `proj/src/utils/TTSService.js`：取消令牌系统、超时控制、错误处理
  - **数据结构**：
    - `currentSpeakId`：Number，speak() 调用计数器
    - `activeSpeakIds`：Set\<Number\>，当前活跃的调用 ID
    - `cancelledSpeakIds`：Set\<Number\>，已取消的调用 ID
  - **关键方法**：
    - `speak(word, options)`：分配 ID、检查取消、清理 ID
    - `stop(setCancelled = true)`：标记取消或仅清理
    - `speakWord(word)`：游戏状态检查
    - `startRepeatedSpeech(word)`：模式差异化逻辑
    - `startBufferCountdown()`：挑战模式缓冲区播放

### 2025-10-08 更新 v11
- **iOS 音频播放优化**：完美解决 iOS 设备 TTS 播放限制问题
  - **问题背景**：
    - iOS Safari 严格限制 Audio 对象的自动播放
    - 需要在直接的用户交互事件中调用 `audio.play()` 才能成功
    - 在定时器、异步回调中播放会被拒绝（NotAllowedError）
    - 音频上下文激活有时效性（3-6秒窗口期后过期）
  
  - **解决方案**：iOS 设备优先使用 Web Speech API
    - **自动设备检测**：通过 User Agent 识别 iOS 设备
    - **提供商优先级调整**：
      - iOS 设备：Web Speech API（第1优先级）> 有道 TTS > 百度 TTS
      - 其他设备：百度 TTS > 有道 TTS > Bing TTS > Web Speech API
    - **音频上下文简化**：
      - iOS：直接激活 Web Speech API（无需复杂的 Audio 解锁）
      - 其他：尝试解锁 Audio 对象播放权限
  
  - **技术优势**：
    - ✅ Web Speech API 是浏览器原生功能，不受 autoplay 限制
    - ✅ 无需网络请求，响应更快
    - ✅ 支持英式发音（自动选择 Google UK English）
    - ✅ 可以在任何时候调用，无需用户交互窗口期
    - ✅ 稳定可靠，不会出现间歇性失败
  
  - **错误处理优化**：
    - iOS 设备的 Audio 播放失败视为正常（已使用 Web Speech API）
    - 自动降级机制：提供商失败时切换到下一个
    - 连续失败 3 次的提供商自动移除
    - 友好的错误提示信息（区分 iOS 和非 iOS 设备）
  
  - **日志优化**：
    - 注释掉缓冲区倒计时日志（红灯/黄灯/绿灯）
    - 注释掉图片加载尝试日志（减少日志刷屏）
    - 保留关键节点日志（倒计时完成、朗读成功/失败）
  
  - **实现文件**：
    - `proj/src/utils/TTSService.js`：TTS 服务核心逻辑
    - `proj/src/core/WordTetrisGame.js`：游戏集成与日志优化

### 2025-10-07 更新 v10
- **单词位置随机化**：优化单词掉落机制
  - **随机位置掉落**：单词从游戏区域上方的随机水平位置开始掉落
  - **智能位置计算**：
    - 根据单词长度动态计算随机 x 坐标
    - 确保单词完全在画布内，不会超出边界
    - 左右各留 20 像素边距，避免贴边显示
  - **随机范围公式**：
    - 最小 x：`单词宽度/2 + 20`
    - 最大 x：`画布宽度 - 单词宽度/2 - 20`
    - 随机 x：在最小和最大之间随机选择
  - **游戏性提升**：
    - 增加游戏趣味性和视觉多样性
    - 提升挑战性，避免单调的固定位置
    - 炮管需要瞄准不同位置的单词
  - **技术实现**：
    - 在 `releaseWord()` 函数中实现
    - 每次释放单词时重新计算随机位置
    - 保持与其他游戏机制的完美兼容

### 2025-10-07 更新 v10
- **重音音节高亮功能**：新增重音可视化学习辅助
  - **功能描述**：单词中的重音音节用红色字母显示
  - **实现原理**：
    - 从音标中识别重音符号（ˈ 主重音，ˌ 次重音）
    - 优先显示主重音，忽略次重音
    - 使用音节划分算法识别整个重音音节
    - 单音节词（无重音符号）不高亮
  - **音节划分规则**：
    - 向左扩展：单个辅音归当前音节
    - 向右扩展：辅音归下一个音节（开音节原则）
    - 单词结尾：包含所有辅音
  - **显示效果**：
    - father [ˈfɑːðə] → **fa**ther（fa 红色）
    - about [əˈbaʊt] → a**bout**（bout 红色）
    - school [skuːl] → school（不高亮）
  - **教育价值**：
    - 帮助学生识别单词重音位置
    - 培养正确的发音习惯
    - 视觉化学习发音规律
  - **技术实现**：
    - vocabulary-manager-v2.js：新增 getStressPositions() 方法
    - vocabulary-manager-v2.js：新增 getWholeSyllable() 音节识别方法
    - game.js：修改 drawWordWithHighlight() 渲染逻辑
    - 单词对象新增 stressPositions 属性
  - **测试验证**：
    - 创建 test-stress-examples.html 测试页面
    - 包含 11 个测试用例
    - 验证不同音节结构的单词
  - **相关文档**：
    - STRESS_SYLLABLE_FEATURE.md：功能详细说明
    - SYLLABLE_DIVISION_RULES.md：音节划分规则
    - STRESS_SYLLABLE_VISUAL_GUIDE.md：可视化说明

### 2025-10-07 更新 v9
- **游戏模式系统**：新增休闲/挑战双模式设计
  - **休闲模式（默认）**：
    - 显示部分字母提示
    - 适合初学者和课堂教学
    - 降低学习门槛，建立基础认知
  - **挑战模式**：
    - 全部字母隐藏，无任何提示
    - 适合复习巩固和能力测试
    - 强化记忆，提升拼写准确性
  - **设置界面优化**：
    - 模式选择位于设置页面顶部
    - 标题和选项在同一行，左右分布
    - 单选按钮设计，简洁直观
    - 间距优化：选项间距60px，标签内间距12px
    - 悬停效果：淡蓝色背景高亮
  - **技术实现**：
    - 模式状态保存到 localStorage
    - 页面加载时自动恢复上次选择
    - 切换时显示提示消息
    - 与游戏逻辑无缝集成

### 2025-10-06 更新 v8.2
- **界面重构**：100% 实现设计文档中的界面布局
  - **三栏式布局**：图片展示区 + 游戏画布 + 侧边栏
  - **图片展示区完整实现**：
    - 200x200px 尺寸，金色渐变边框
    - 三层信息结构（图片 70% + 单词信息 15% + 中文翻译 15%）
    - 成功闪烁动画（绿色边框，0.6秒）
    - 错误抖动动画（左右摆动，0.5秒）
    - 加载指示器（脉冲动画）
  - **响应式布局**：移动端自动切换为垂直布局
  - **游戏控制区**：独立区域，位于游戏主体下方
  - **完美适配高清屏**：DPI 自适应
  - **集成到游戏逻辑**：
    - 单词下降时自动更新图片
    - 成功射击触发绿色闪烁特效
    - 错误输入触发抖动特效
    - 图片缓存系统（localStorage + LRU）

### 2025-10-06 更新 v8.1
- **图片缓存目录系统**：优化图片管理机制
  - **自动缓存目录**：`proj/images/cache/`
    - 从 API 下载的图片自动保存到缓存目录
    - 下次直接从缓存读取，避免重复下载
    - 节省带宽，提高加载速度
  - **预置图片库**：`proj/images/words/`
    - 可选的高质量图片库
    - 手动准备，适合离线部署
    - 优先级高于 API 下载
  - **智能加载策略**：
    1. 检查缓存目录 → 2. 检查预置图片 → 3. API下载并缓存 → 4. 占位符
  - **缓存管理**：
    - 容量限制：最多 500 个图片
    - 自动清理：LRU算法 + 90天过期
    - 元数据记录：cache-metadata.json
    - 并发控制：最多同时下载 3 个图片
  - **Git 管理**：
    - `.gitignore` 忽略 cache/ 目录
    - 缓存文件不提交到版本控制
  - **技术实现**：
    - ImageFileCache 类：文件缓存系统
    - 下载队列管理：并发控制 + 失败重试
    - Blob URL 管理：内存优化
    - 缓存统计功能

### 2025-10-06 更新 v8
- **单词图片展示功能**：新增视觉化学习辅助系统
  - **设计理念**：建立"英文单词 ↔ 图像 ↔ 中文意思"三重记忆关联
  - **界面布局**：游戏画布左侧新增 200x200px 图片展示区
  - **展示内容**：
    - 图片区域（70%）：单词对应的视觉图片
    - 单词信息区（15%）：英文单词 + 音标
    - 中文翻译区（15%）：中文翻译
  - **视觉样式**：
    - 金色渐变边框 + 柔和外发光
    - 半透明深色背景 + 毛玻璃效果
    - 圆角设计，现代美观
  - **动画效果**：
    - 图片加载淡入（0.5秒）
    - 单词切换滑动（0.6秒）
    - 成功射击绿色闪烁（3次，每次0.2秒）
    - 错误输入抖动（0.5秒，±5px）
    - 加载中脉冲动画
  - **图片来源策略**（多层级降级）：
    - 优先级1：本地图片库（proj/images/words/）
    - 优先级2：Unsplash API（免费，高质量）
    - 优先级3：图标字体（Font Awesome）
    - 优先级4：纯色占位符（渐变背景 + 首字母）
  - **缓存机制**：
    - localStorage 缓存图片 URL，7天过期
    - 最多缓存 100 个单词
    - LRU 清理算法
    - 预加载下一个单词图片
  - **技术实现**：
    - WordImageManager：图片管理器
    - ImageLoader：异步加载器（5秒超时，最多重试3次）
    - ImageRenderer：DOM渲染器（CSS动画）
    - PlaceholderGenerator：占位符生成器
    - ImageCache：缓存系统
  - **教育价值**：
    - 多感官学习：视觉 + 听觉 + 动作
    - 情境关联：图片提供使用情境
    - 趣味性提升：丰富视觉内容
    - 即时反馈：图片特效配合游戏反馈
  - **性能优化**：
    - 图片压缩到 200x200px
    - WebP 格式优先，降级到 JPEG
    - 懒加载机制
    - 及时释放图片资源

### 2025-10-05 更新 v7
- **三级层级化词库分类系统**：重构词库组织架构
  - **按天学习音标（15天课程）**：
    - Day 1-14：系统化音标学习，每天一个重点音标
    - 包含长元音、短元音、双元音、中性元音等
    - 每天10-15个精选单词，配合音标发音练习
  - **专项强化练习（4个专项）**：
    - /æ/ 专项练习：20个重点单词
    - /e/ 专项练习：20个重点单词
    - /ɔ:/ 专项练习：20个重点单词
    - /ɒ/ 专项练习：18个重点单词
  - **按年级分类（小学/初中/高中）**：
    - 小学词汇：三至六年级，每年级分上下学期（8个学期）
    - 初中词汇：七至九年级，每年级分上下学期（6个学期）
    - 高中词汇：高一至高三，每年级分上下学期（6个学期）
    - 共20个学期，覆盖基础教育全阶段
- **可视化层级选择界面**：
  - 三级展开/折叠功能：大分类→子分类→具体课程
  - 实时统计显示：已选课程数、总单词数、难度范围
  - 批量操作支持：分类全选、年级全选、一键重置
  - 选中状态可视化：绿色高亮+勾选标记
- **目录结构优化**：
  ```
  words/
  ├── config-v2.json           # 层级化配置文件
  ├── daily-phonics/           # 按天学习音标
  │   ├── day01.json          # Day 1课程
  │   ├── day02.json          # Day 2课程
  │   └── ...
  ├── special-practice/        # 专项练习
  │   ├── ae-practice.json    # /æ/专项
  │   ├── e-practice.json     # /e/专项
  │   └── ...
  └── grade-based/            # 按年级分类
      ├── primary/            # 小学
      │   ├── grade3-term1.json
      │   └── ...
      ├── middle/             # 初中
      │   └── ...
      └── high/               # 高中
          └── ...
  ```

### 2025-10-05 更新 v6
- **分布式单词库架构**：重构单词库管理系统
  - 单词库分离：将单个大文件拆分为多个主题文件（基础音标、专项练习、常用单词等）
  - 配置化管理：通过config.json统一管理所有可用词库的元数据和配置
  - 动态加载：支持按需加载指定的词库文件，减少初始加载时间
  - 用户自定义：提供设置页面让用户选择启用哪些词库进行练习
- **词库设置系统**：新增专门的设置页面
  - 词库选择界面：可视化展示所有可用词库，支持启用/禁用切换
  - 词库信息展示：显示每个词库的描述、单词数量、难度等级、推荐状态
  - 高级设置选项：最大单词数、难度范围等个性化配置
  - 实时预览：配置变更时实时显示影响的单词数量和统计信息
- **技术架构升级**：
  - VocabularyManagerV2：全新的分布式词汇管理器
  - 异步加载机制：支持并行加载多个词库文件
  - 本地存储集成：用户设置自动保存到localStorage
  - 错误处理增强：更友好的加载失败提示和降级方案

### 2025-10-05 更新 v5
- **界面显示优化**：提升单词可见性和用户体验
  - 单词字体增大：主要单词从20px增加到32px，缓冲区单词从24px增加到28px
  - 输入字母小写化：用户输入的字母以小写形式显示，但验证时仍转为大写比较
  - 生词本总数显示：生词本标题显示当前生词数量，格式为"生词本 (数量)"
- **统计系统修正**：修复命中率计算逻辑错误
  - 命中率重新定义：命中单词数 ÷ 下落单词数（去重）× 100%
  - 覆盖率保持不变：命中单词数 ÷ 总单词库数量 × 100%
  - 新增下落单词统计：跟踪所有下落过的单词（去重），用于准确计算命中率
- **游戏流程优化**：简化用户操作流程
  - 页面刷新自动重置：页面加载时自动执行游戏重置，清空所有数据
  - 重置按钮自动开始：点击重置按钮后自动开始游戏，实现一键重新开始
  - 区分重置类型：手动重置自动开始，刷新重置仅重置不开始

### 2025-10-05 更新 v4
- **生词本逻辑修正**：修复生词本清空逻辑错误
  - 升级时保留生词本：升级不清空生词本，持续累积学习记录
  - 重置时清空生词本：只有重置游戏时才清空生词本和统计数据
- **考试统计系统**：新增考试进度跟踪功能
  - 考试总词量显示：显示单词库总数（135个单词）
  - 正确命中统计：记录成功射击的不重复单词数量
  - 覆盖率计算：正确命中数 / 总词量 × 100%（表示学习进度）
  - 去重机制：同一单词多次命中只计算一次
  - 实时更新：每次成功射击后立即更新显示
  - 注：v5版本中修正了命中率计算逻辑

### 2025-10-05 更新 v3
- **单词级别互斥原则**：确保每个单词只出现在一个难度级别中
  - 核心规则：严格分离、无重复、独立词库、渐进难度
  - 技术实现：修改筛选逻辑，使用 `difficulty === targetDifficulty`
  - 质量保证：自动去重、分布验证、警告机制
  - 级别分配：Level 1-2使用难度1，Level 3-4使用难度2，Level 5+使用难度3

### 2025-10-05 更新 v2
- **全局键盘响应**：实现无需点击输入框的键盘输入
  - 字母键直接输入、Enter提交、Backspace删除、Space放弃
  - 移除备用单词库，优化错误处理机制
  - 等级提升弹窗自动关闭和键盘快捷键支持

### 2025-10-05 更新 v1
- **单词显示优化**：统一使用小写字母显示所有单词
  - 视觉设计：在颜色方案中明确要求小写字母显示
  - 技术实现：在界面渲染模块中添加大小写控制功能
  - 用户体验：降低视觉压迫感，符合阅读习惯
  - 界面示例：更新所有示例为小写字母显示

---

**这个游戏方案结合了娱乐性和教育性，有望成为一个成功的英语学习工具！** 🌟

**让学习变得有趣，让游戏变得有意义！** 🎮📚