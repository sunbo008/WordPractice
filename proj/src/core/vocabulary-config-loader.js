/**
 * åŠ¨æ€è¯åº“é…ç½®åŠ è½½å™¨
 * è¿è¡Œæ—¶è‡ªåŠ¨æ‰«æ words ç›®å½•ï¼Œç”Ÿæˆé…ç½®
 */
class VocabularyConfigLoader {
    constructor() {
        this.config = null;
        this.loadError = null;
    }
    
    /**
     * åŠ è½½é…ç½®ï¼ˆè¿è¡Œæ—¶åŠ¨æ€ç”Ÿæˆï¼‰
     */
    async loadConfig() {
        try {
            console.log('ğŸ”„ å¼€å§‹åŠ¨æ€åŠ è½½è¯åº“é…ç½®...');
            
            // å¹¶è¡Œæ‰«ææ‰€æœ‰ç›®å½•
            const [dailyPhonics, specialPractice, gradeBased] = await Promise.all([
                this.scanDailyPhonics(),
                this.scanSpecialPractice(),
                this.scanGradeBased()
            ]);
            
            // æ„å»ºé…ç½®å¯¹è±¡
            this.config = {
                metadata: {
                    version: "2.0",
                    description: "Word Tetris åˆ†å¸ƒå¼è¯åº“é…ç½® - è¿è¡Œæ—¶åŠ¨æ€ç”Ÿæˆ",
                    lastUpdated: new Date().toISOString().split('T')[0],
                    autoGenerated: true,
                    generatedBy: "JavaScript Runtime"
                },
                categories: [
                    {
                        id: "daily-phonics",
                        name: "æŒ‰å¤©å­¦ä¹ éŸ³æ ‡",
                        description: "15å¤©éŸ³æ ‡å­¦ä¹ è®¡åˆ’ï¼Œç³»ç»ŸæŒæ¡åŸºç¡€éŸ³æ ‡",
                        icon: "ğŸ“…",
                        subcategories: dailyPhonics
                    },
                    {
                        id: "special-practice",
                        name: "ä¸“é¡¹å¼ºåŒ–ç»ƒä¹ ",
                        description: "é’ˆå¯¹é‡ç‚¹éŸ³æ ‡è¿›è¡Œå¼ºåŒ–è®­ç»ƒ",
                        icon: "ğŸ¯",
                        subcategories: specialPractice
                    },
                    {
                        id: "grade-based",
                        name: "æŒ‰å¹´çº§åˆ†ç±»",
                        description: "å°å­¦ã€åˆä¸­ã€é«˜ä¸­å„å¹´çº§å­¦æœŸè¯æ±‡",
                        icon: "ğŸ“",
                        subcategories: gradeBased
                    }
                ],
                defaultConfig: {
                    // ä½¿ç”¨åŠ¨æ€å‘ç°çš„æ‰€æœ‰ daily-phonics æ–‡ä»¶ä½œä¸ºé»˜è®¤é…ç½®
                    enabledLibraries: dailyPhonics.map(item => item.id),
                    maxWords: 200,
                    difficultyRange: [1, 3],
                    categories: ["daily-phonics"]
                }
            };
            
            console.log('âœ… é…ç½®åŠ è½½å®Œæˆ:', {
                dailyPhonics: dailyPhonics.length,
                specialPractice: specialPractice.length,
                gradeBased: this.countGradeItems(gradeBased),
                defaultEnabled: this.config.defaultConfig.enabledLibraries.length
            });
            
            console.log('ğŸ“‹ é»˜è®¤å¯ç”¨çš„è¯¾ç¨‹:', this.config.defaultConfig.enabledLibraries);
            
            return this.config;
            
        } catch (error) {
            console.error('âŒ é…ç½®åŠ è½½å¤±è´¥:', error);
            this.loadError = error;
            throw error;
        }
    }
    
    /**
     * æ‰«æ daily-phonics ç›®å½•
     * è‡ªåŠ¨æ¢æµ‹ day01.json åˆ° day50.json çš„æ‰€æœ‰æ–‡ä»¶
     */
    async scanDailyPhonics() {
        const directory = './words/daily-phonics';
        const results = [];
        
        console.log('ğŸ” æ‰«æ daily-phonics ç›®å½•...');
        
        // åŠ¨æ€æ¢æµ‹ day01 åˆ° day50 çš„æ‰€æœ‰æ–‡ä»¶
        for (let i = 1; i <= 50; i++) {
            const filename = `day${String(i).padStart(2, '0')}`;
            const filepath = `${directory}/${filename}.json`;
            
            try {
                const response = await fetch(filepath, { method: 'HEAD' });
                if (!response.ok) continue; // æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡
                
                // æ–‡ä»¶å­˜åœ¨ï¼Œè·å–å®Œæ•´æ•°æ®
                const fullResponse = await fetch(filepath);
                const data = await fullResponse.json();
                const metadata = data.metadata || {};
                
                results.push({
                    id: metadata.id || filename,
                    name: metadata.name || `Day ${i}`,
                    filename: `daily-phonics/${filename}.json`,
                    phoneme: metadata.phoneme || '',
                    description: metadata.description || '',
                    wordCount: metadata.wordCount || data.words?.length || 0,
                    difficulty: metadata.difficulty || 'beginner',
                    recommended: true
                });
                
                console.log(`  âœ“ å‘ç°æ–‡ä»¶: ${filename}.json (${metadata.name || filename})`);
            } catch (error) {
                // æ–‡ä»¶ä¸å­˜åœ¨æˆ–è§£æå¤±è´¥ï¼Œé™é»˜è·³è¿‡
            }
        }
        
        console.log(`âœ… daily-phonics æ‰«æå®Œæˆï¼Œå‘ç° ${results.length} ä¸ªæ–‡ä»¶`);
        return results.sort((a, b) => a.id.localeCompare(b.id));
    }
    
    /**
     * æ‰«æ special-practice ç›®å½•
     * è‡ªåŠ¨æ¢æµ‹å¸¸è§çš„éŸ³æ ‡ç»ƒä¹ æ–‡ä»¶å‘½åæ¨¡å¼
     */
    async scanSpecialPractice() {
        const directory = './words/special-practice';
        const results = [];
        
        console.log('ğŸ” æ‰«æ special-practice ç›®å½•...');
        
        // å¸¸è§çš„éŸ³æ ‡å’Œç»ƒä¹ æ–‡ä»¶å‘½åæ¨¡å¼
        const potentialFiles = [
            // å…ƒéŸ³éŸ³æ ‡
            'ae-practice', 'e-practice', 'i-practice', 'o-practice', 'or-practice', 'u-practice',
            'a-practice', 'ar-practice', 'er-practice', 'ir-practice', 'ur-practice',
            'oo-practice', 'ou-practice', 'ow-practice', 'oi-practice', 'oy-practice',
            'ai-practice', 'ay-practice', 'ea-practice', 'ee-practice', 'ie-practice',
            'ue-practice', 'ui-practice', 'au-practice', 'aw-practice', 'ew-practice',
            // è¾…éŸ³éŸ³æ ‡
            'th-practice', 'sh-practice', 'ch-practice', 'ph-practice', 'wh-practice',
            'ng-practice', 'nk-practice', 'ck-practice', 'gh-practice',
            // å…¶ä»–å¯èƒ½çš„å‘½å
            'vowels-practice', 'consonants-practice', 'diphthongs-practice',
            'long-vowels', 'short-vowels', 'silent-e', 'r-controlled',
            // æ•°å­—å‘½åï¼ˆå¦‚æœæœ‰ï¼‰
            ...Array.from({length: 20}, (_, i) => `special${String(i + 1).padStart(2, '0')}`)
        ];
        
        for (const filename of potentialFiles) {
            const filepath = `${directory}/${filename}.json`;
            
            try {
                const response = await fetch(filepath, { method: 'HEAD' });
                if (!response.ok) continue;
                
                // æ–‡ä»¶å­˜åœ¨ï¼Œè·å–å®Œæ•´æ•°æ®
                const fullResponse = await fetch(filepath);
                const data = await fullResponse.json();
                const metadata = data.metadata || {};
                
                results.push({
                    id: metadata.id || filename,
                    name: metadata.name || filename.replace(/-/g, ' '),
                    filename: `special-practice/${filename}.json`,
                    phoneme: metadata.phoneme || '',
                    description: metadata.description || '',
                    wordCount: metadata.wordCount || data.words?.length || 0,
                    difficulty: metadata.difficulty || 'intermediate',
                    recommended: false
                });
                
                console.log(`  âœ“ å‘ç°æ–‡ä»¶: ${filename}.json (${metadata.name || filename})`);
            } catch (error) {
                // æ–‡ä»¶ä¸å­˜åœ¨æˆ–è§£æå¤±è´¥ï¼Œé™é»˜è·³è¿‡
            }
        }
        
        console.log(`âœ… special-practice æ‰«æå®Œæˆï¼Œå‘ç° ${results.length} ä¸ªæ–‡ä»¶`);
        return results;
    }
    
    /**
     * æ‰«æ grade-based ç›®å½•
     * è‡ªåŠ¨æ¢æµ‹æ‰€æœ‰å¹´çº§å’Œå­¦æœŸçš„æ–‡ä»¶
     */
    async scanGradeBased() {
        console.log('ğŸ” æ‰«æ grade-based ç›®å½•...');
        
        const gradeStructure = {
            primary: {
                id: "primary-school",
                name: "å°å­¦è¯æ±‡",
                description: "å°å­¦ä¸‰è‡³å…­å¹´çº§è¯æ±‡",
                // åŠ¨æ€æ¢æµ‹ grade1-grade6 çš„æ‰€æœ‰å­¦æœŸ
                gradeRange: [1, 2, 3, 4, 5, 6],
                defaultWords: 60
            },
            middle: {
                id: "middle-school",
                name: "åˆä¸­è¯æ±‡",
                description: "åˆä¸­ä¸ƒè‡³ä¹å¹´çº§è¯æ±‡",
                // åŠ¨æ€æ¢æµ‹ grade7-grade9
                gradeRange: [7, 8, 9],
                defaultWords: 120
            },
            high: {
                id: "high-school",
                name: "é«˜ä¸­è¯æ±‡",
                description: "é«˜ä¸­åè‡³åäºŒå¹´çº§è¯æ±‡",
                // åŠ¨æ€æ¢æµ‹ grade10-grade12
                gradeRange: [10, 11, 12],
                defaultWords: 200
            }
        };
        
        const subcategories = [];
        
        for (const [levelKey, levelInfo] of Object.entries(gradeStructure)) {
            const items = [];
            
            // åŠ¨æ€æ¢æµ‹æ¯ä¸ªå¹´çº§çš„ä¸¤ä¸ªå­¦æœŸ
            for (const gradeNum of levelInfo.gradeRange) {
                for (const term of [1, 2]) {
                    const gradeId = `grade${gradeNum}-term${term}`;
                    const filepath = `./words/grade-based/${levelKey}/${gradeId}.json`;
                    
                    try {
                        const response = await fetch(filepath, { method: 'HEAD' });
                        if (response.ok) {
                            // æ–‡ä»¶å­˜åœ¨ï¼Œè·å–å®Œæ•´æ•°æ®
                            const fullResponse = await fetch(filepath);
                            const data = await fullResponse.json();
                            const metadata = data.metadata || {};
                            
                            // ç”Ÿæˆå¹´çº§åç§°
                            const gradeName = this.getGradeName(gradeNum, term);
                            
                            items.push({
                                id: metadata.id || gradeId,
                                name: metadata.name || gradeName,
                                filename: `grade-based/${levelKey}/${gradeId}.json`,
                                description: metadata.description || `${gradeName}å¿…å­¦è¯æ±‡`,
                                wordCount: metadata.wordCount || data.words?.length || levelInfo.defaultWords,
                                difficulty: metadata.difficulty || 'beginner',
                                recommended: true
                            });
                            
                            console.log(`  âœ“ å‘ç°æ–‡ä»¶: ${levelKey}/${gradeId}.json (${metadata.name || gradeName})`);
                        }
                    } catch (error) {
                        // æ–‡ä»¶ä¸å­˜åœ¨æˆ–è§£æå¤±è´¥ï¼Œé™é»˜è·³è¿‡
                    }
                }
            }
            
            // åªæœ‰åœ¨æ‰¾åˆ°è‡³å°‘ä¸€ä¸ªæ–‡ä»¶æ—¶æ‰æ·»åŠ è¿™ä¸ªåˆ†ç±»
            if (items.length > 0) {
                subcategories.push({
                    id: levelInfo.id,
                    name: levelInfo.name,
                    description: levelInfo.description,
                    items: items
                });
                console.log(`  âœ“ ${levelInfo.name}: å‘ç° ${items.length} ä¸ªæ–‡ä»¶`);
            }
        }
        
        console.log(`âœ… grade-based æ‰«æå®Œæˆï¼Œå‘ç° ${subcategories.length} ä¸ªåˆ†ç±»`);
        return subcategories;
    }
    
    /**
     * ç”Ÿæˆå¹´çº§åç§°
     */
    getGradeName(gradeNum, term) {
        const gradeNames = {
            1: 'ä¸€å¹´çº§', 2: 'äºŒå¹´çº§', 3: 'ä¸‰å¹´çº§', 4: 'å››å¹´çº§', 5: 'äº”å¹´çº§', 6: 'å…­å¹´çº§',
            7: 'ä¸ƒå¹´çº§', 8: 'å…«å¹´çº§', 9: 'ä¹å¹´çº§',
            10: 'é«˜ä¸€', 11: 'é«˜äºŒ', 12: 'é«˜ä¸‰'
        };
        const termName = term === 1 ? 'ä¸Šå­¦æœŸ' : 'ä¸‹å­¦æœŸ';
        return `${gradeNames[gradeNum] || `${gradeNum}å¹´çº§`}${termName}`;
    }
    
    /**
     * ç»Ÿè®¡å¹´çº§åˆ†ç±»çš„é¡¹ç›®æ•°
     */
    countGradeItems(gradeBased) {
        return gradeBased.reduce((sum, category) => sum + category.items.length, 0);
    }
    
    /**
     * è·å–é…ç½®
     */
    getConfig() {
        return this.config;
    }
}

// å¯¼å‡ºå•ä¾‹
window.VocabularyConfigLoader = VocabularyConfigLoader;

