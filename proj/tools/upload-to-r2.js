/**
 * Cloudflare R2 ËµÑÊ∫ê‰∏ä‰º†ËÑöÊú¨ÔºàÂ∏¶Êú¨Âú∞ÁºìÂ≠ò‰ºòÂåñÔºâ
 * 
 * ÂäüËÉΩÔºö
 * 1. Â∞Ü proj/images/cache/ Âíå proj/audio/ ÁõÆÂΩï‰∏≠ÁöÑËµÑÊ∫ê‰∏ä‰º†Âà∞ Cloudflare R2
 * 2. ‰øùÊåÅÂéüÊúâÁõÆÂΩïÁªìÊûÑ
 * 3. ÊîØÊåÅÊñ≠ÁÇπÁª≠‰º†ÔºàË∑≥ËøáÂ∑≤‰∏ä‰º†Êñá‰ª∂Ôºâ
 * 4. Êú¨Âú∞ÁºìÂ≠ò‰∏ä‰º†ËÆ∞ÂΩïÔºåÈÅøÂÖçÈ¢ëÁπÅÊü•ËØ¢ÊúçÂä°Âô®
 * 5. ÊòæÁ§∫‰∏ä‰º†ËøõÂ∫¶
 * 
 * ‰ºòÂåñÁâπÊÄßÔºö
 * - Êú¨Âú∞‰øùÂ≠ò‰∏ä‰º†ËÆ∞ÂΩïÔºåÂ§ßÂ§ßÂáèÂ∞ë API ËØ∑Ê±Ç
 * - Ëá™Âä®ÂêåÊ≠•ÊúçÂä°Âô®Áä∂ÊÄÅÔºàÂèëÁé∞ÊúçÂä°Âô®Â∑≤Êúâ‰ΩÜÊú¨Âú∞Êú™ËÆ∞ÂΩïÁöÑÊñá‰ª∂‰ºöË°•ÂÖÖËÆ∞ÂΩïÔºâ
 * - Ê£ÄÊµãÊñá‰ª∂‰øÆÊîπÊó∂Èó¥ÔºåËá™Âä®ÈáçÊñ∞‰∏ä‰º†ÂèòÊõ¥ÁöÑÊñá‰ª∂
 * 
 * ‰ΩøÁî®ÊñπÊ≥ïÔºö
 * 1. ÂÆâË£Ö‰æùËµñÔºönpm install
 * 2. ÈÖçÁΩÆÁéØÂ¢ÉÂèòÈáèÔºàÂú®È°πÁõÆÊ†πÁõÆÂΩïÂàõÂª∫ .env Êñá‰ª∂Ôºâ
 * 3. ËøêË°åÔºönode upload-to-r2.js
 */

const { S3Client, PutObjectCommand, HeadObjectCommand } = require('@aws-sdk/client-s3');
const fs = require('fs');
const path = require('path');
const mime = require('mime-types');
require('dotenv').config({ path: path.join(__dirname, '../../.env') });

// ============================================
// ÈÖçÁΩÆÂå∫Âüü - ËØ∑Âú®È°πÁõÆÊ†πÁõÆÂΩïÁöÑ .env Êñá‰ª∂‰∏≠ËÆæÁΩÆËøô‰∫õÂèòÈáè
// ============================================

const config = {
    // Cloudflare R2 ÈÖçÁΩÆ
    accountId: process.env.R2_ACCOUNT_ID || '',
    accessKeyId: process.env.R2_ACCESS_KEY_ID || '',
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY || '',
    bucketName: process.env.R2_BUCKET_NAME || 'wordpractice-assets',
    
    // ‰∏ä‰º†ÁõÆÂΩïÈÖçÁΩÆÔºàÁõ∏ÂØπ‰∫éÈ°πÁõÆÊ†πÁõÆÂΩïÔºâ
    // ‰∏ä‰º†ÂõæÁâáÂíåÈü≥È¢ëÊñá‰ª∂
    uploadDirs: [
        { local: path.join(__dirname, '../images/cache'), remote: 'images/cache' },
        { local: path.join(__dirname, '../audio'), remote: 'audio' }
    ],
    
    // Êú¨Âú∞‰∏ä‰º†ËÆ∞ÂΩïÁºìÂ≠òÊñá‰ª∂
    cacheFile: path.join(__dirname, '.upload-cache.json'),
    
    // ÊòØÂê¶Âº∫Âà∂ÈáçÊñ∞‰∏ä‰º†Ôºàfalse = Ë∑≥ËøáÂ∑≤Â≠òÂú®Êñá‰ª∂Ôºâ
    forceUpload: process.env.FORCE_UPLOAD === 'true',
};

// ============================================
// ‰∏ä‰º†ËÆ∞ÂΩïÁºìÂ≠òÁÆ°ÁêÜ
// ============================================

class UploadCache {
    constructor(cacheFile) {
        this.cacheFile = cacheFile;
        this.cache = this.load();
        this.modified = false;
    }
    
    /**
     * Âä†ËΩΩ‰∏ä‰º†ËÆ∞ÂΩï
     */
    load() {
        if (fs.existsSync(this.cacheFile)) {
            try {
                const data = fs.readFileSync(this.cacheFile, 'utf-8');
                const cache = JSON.parse(data);
                console.log(`üìã Âä†ËΩΩ‰∏ä‰º†ËÆ∞ÂΩï: ${Object.keys(cache.files || {}).length} ‰∏™Êñá‰ª∂`);
                return cache;
            } catch (error) {
                console.warn('‚ö†Ô∏è  ‰∏ä‰º†ËÆ∞ÂΩïÊñá‰ª∂ÊçüÂùèÔºåÂ∞ÜÂàõÂª∫Êñ∞ËÆ∞ÂΩï');
                return this.createEmpty();
            }
        }
        return this.createEmpty();
    }
    
    /**
     * ÂàõÂª∫Á©∫ËÆ∞ÂΩï
     */
    createEmpty() {
        return {
            version: '1.0',
            lastUpdate: new Date().toISOString(),
            files: {}
        };
    }
    
    /**
     * ‰øùÂ≠ò‰∏ä‰º†ËÆ∞ÂΩï
     */
    save() {
        if (!this.modified) {
            return;
        }
        
        this.cache.lastUpdate = new Date().toISOString();
        fs.writeFileSync(this.cacheFile, JSON.stringify(this.cache, null, 2), 'utf-8');
        console.log(`üíæ Â∑≤‰øùÂ≠ò‰∏ä‰º†ËÆ∞ÂΩï: ${Object.keys(this.cache.files).length} ‰∏™Êñá‰ª∂`);
        this.modified = false;
    }
    
    /**
     * Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â∑≤‰∏ä‰º†ÔºàÂü∫‰∫éÊú¨Âú∞ËÆ∞ÂΩïÔºâ
     */
    isUploaded(remotePath, localStat) {
        const record = this.cache.files[remotePath];
        if (!record || !record.uploaded) {
            return false;
        }
        
        // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Ë¢´‰øÆÊîπÔºàÈÄöËøá‰øÆÊîπÊó∂Èó¥ÂíåÂ§ßÂ∞èÔºâ
        if (record.size !== localStat.size || record.mtime !== localStat.mtimeMs) {
            return false;
        }
        
        return true;
    }
    
    /**
     * Ê†áËÆ∞Êñá‰ª∂Â∑≤‰∏ä‰º†
     */
    markUploaded(remotePath, localStat) {
        this.cache.files[remotePath] = {
            uploaded: true,
            size: localStat.size,
            mtime: localStat.mtimeMs,
            uploadedAt: new Date().toISOString()
        };
        this.modified = true;
    }
    
    /**
     * Ëé∑ÂèñÁªüËÆ°‰ø°ÊÅØ
     */
    getStats() {
        const files = Object.values(this.cache.files);
        return {
            total: files.length,
            uploaded: files.filter(f => f.uploaded).length
        };
    }
}

// ============================================
// Ê£ÄÊü•ÈÖçÁΩÆ
// ============================================

function checkConfig() {
    const missing = [];
    if (!config.accountId) missing.push('R2_ACCOUNT_ID');
    if (!config.accessKeyId) missing.push('R2_ACCESS_KEY_ID');
    if (!config.secretAccessKey) missing.push('R2_SECRET_ACCESS_KEY');
    
    if (missing.length > 0) {
        console.error('‚ùå Áº∫Â∞ëÂøÖË¶ÅÁöÑÁéØÂ¢ÉÂèòÈáèÔºö', missing.join(', '));
        console.log('\nËØ∑Âú®È°πÁõÆÊ†πÁõÆÂΩïÂàõÂª∫ .env Êñá‰ª∂Âπ∂ËÆæÁΩÆ‰ª•‰∏ãÂèòÈáèÔºö');
        console.log('‰ΩçÁΩÆÔºöWordPractice/.env (‰∏é README.md ÂêåÁ∫ß)\n');
        console.log('R2_ACCOUNT_ID=your_account_id');
        console.log('R2_ACCESS_KEY_ID=your_access_key_id');
        console.log('R2_SECRET_ACCESS_KEY=your_secret_access_key');
        console.log('R2_BUCKET_NAME=wordpractice-assets (ÂèØÈÄâÔºåÈªòËÆ§‰∏∫ wordpractice-assets)');
        console.log('\nÂø´ÈÄüÂàõÂª∫Ôºö');
        console.log('  cd ../..  # ËøîÂõûÈ°πÁõÆÊ†πÁõÆÂΩï');
        console.log('  cp .env.example .env');
        console.log('  nano .env  # ÁºñËæëÈÖçÁΩÆ');
        process.exit(1);
    }
}

// ============================================
// ÂàõÂª∫ R2 ÂÆ¢Êà∑Á´Ø
// ============================================

function createR2Client() {
    return new S3Client({
        region: 'auto',
        endpoint: `https://${config.accountId}.r2.cloudflarestorage.com`,
        credentials: {
            accessKeyId: config.accessKeyId,
            secretAccessKey: config.secretAccessKey,
        },
    });
}

// ============================================
// Êñá‰ª∂Êìç‰ΩúÂáΩÊï∞
// ============================================

/**
 * ÈÄíÂΩíËé∑ÂèñÁõÆÂΩï‰∏ãÊâÄÊúâÊñá‰ª∂
 */
function getAllFiles(dir, fileList = []) {
    const files = fs.readdirSync(dir);
    
    files.forEach(file => {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);
        
        if (stat.isDirectory()) {
            getAllFiles(filePath, fileList);
        } else {
            fileList.push(filePath);
        }
    });
    
    return fileList;
}

/**
 * Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â∑≤Â≠òÂú®‰∫é R2
 */
async function fileExistsInR2(client, bucketName, key) {
    try {
        await client.send(new HeadObjectCommand({
            Bucket: bucketName,
            Key: key,
        }));
        return true;
    } catch (error) {
        if (error.name === 'NotFound') {
            return false;
        }
        throw error;
    }
}

/**
 * ‰∏ä‰º†Âçï‰∏™Êñá‰ª∂Âà∞ R2
 */
async function uploadFile(client, bucketName, localPath, remotePath) {
    const fileContent = fs.readFileSync(localPath);
    const contentType = mime.lookup(localPath) || 'application/octet-stream';
    
    await client.send(new PutObjectCommand({
        Bucket: bucketName,
        Key: remotePath,
        Body: fileContent,
        ContentType: contentType,
    }));
}

/**
 * Ê†ºÂºèÂåñÊñá‰ª∂Â§ßÂ∞è
 */
function formatSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
}

// ============================================
// ‰∏ª‰∏ä‰º†ÈÄªËæëÔºà‰ºòÂåñÁâàÔºâ
// ============================================

async function uploadDirectory(client, localDir, remotePrefix, uploadCache) {
    console.log(`\nüìÅ Êâ´ÊèèÁõÆÂΩï: ${localDir}`);
    
    const files = getAllFiles(localDir);
    console.log(`‚úÖ ÊâæÂà∞ ${files.length} ‰∏™Êñá‰ª∂`);
    
    let uploaded = 0;
    let skippedCache = 0;  // ÈÄöËøáÊú¨Âú∞ÁºìÂ≠òË∑≥Ëøá
    let skippedServer = 0; // ÈÄöËøáÊúçÂä°Âô®Êü•ËØ¢Ë∑≥Ëøá
    let failed = 0;
    let totalSize = 0;
    let apiCalls = 0;      // API Ë∞ÉÁî®Ê¨°Êï∞
    
    for (let i = 0; i < files.length; i++) {
        const localPath = files[i];
        const relativePath = path.relative(localDir, localPath);
        const remotePath = `${remotePrefix}/${relativePath}`.replace(/\\/g, '/');
        
        const stat = fs.statSync(localPath);
        const fileSize = stat.size;
        
        try {
            // Âº∫Âà∂‰∏ä‰º†Ê®°ÂºèÔºöÁõ¥Êé•‰∏ä‰º†ÊâÄÊúâÊñá‰ª∂
            if (config.forceUpload) {
                await uploadFile(client, config.bucketName, localPath, remotePath);
                apiCalls++;
                uploaded++;
                totalSize += fileSize;
                uploadCache.markUploaded(remotePath, stat);
                console.log(`‚úÖ [${i + 1}/${files.length}] Âº∫Âà∂‰∏ä‰º†: ${remotePath} (${formatSize(fileSize)})`);
                continue;
            }
            
            // 1. ÂÖàÊ£ÄÊü•Êú¨Âú∞ÁºìÂ≠ò
            if (uploadCache.isUploaded(remotePath, stat)) {
                skippedCache++;
                console.log(`‚ö° [${i + 1}/${files.length}] ÁºìÂ≠òË∑≥Ëøá: ${remotePath}`);
                continue;
            }
            
            // 2. Êú¨Âú∞ÁºìÂ≠òÊ≤°ÊúâËÆ∞ÂΩïÔºåÊü•ËØ¢ÊúçÂä°Âô®
            const existsInR2 = await fileExistsInR2(client, config.bucketName, remotePath);
            apiCalls++;
            
            if (existsInR2) {
                // ÊúçÂä°Âô®Â∑≤ÊúâÊñá‰ª∂ÔºåË°•ÂÖÖÂà∞Êú¨Âú∞ÁºìÂ≠ò
                skippedServer++;
                uploadCache.markUploaded(remotePath, stat);
                console.log(`üîÑ [${i + 1}/${files.length}] ÂêåÊ≠•ËÆ∞ÂΩï: ${remotePath}`);
                continue;
            }
            
            // 3. Êñá‰ª∂‰∏çÂ≠òÂú®ÔºåÊâßË°å‰∏ä‰º†
            await uploadFile(client, config.bucketName, localPath, remotePath);
            apiCalls++;
            uploaded++;
            totalSize += fileSize;
            uploadCache.markUploaded(remotePath, stat);
            console.log(`‚úÖ [${i + 1}/${files.length}] ‰∏ä‰º†ÊàêÂäü: ${remotePath} (${formatSize(fileSize)})`);
            
        } catch (error) {
            failed++;
            console.error(`‚ùå [${i + 1}/${files.length}] ‰∏ä‰º†Â§±Ë¥•: ${remotePath}`, error.message);
        }
    }
    
    return { uploaded, skippedCache, skippedServer, failed, totalSize, apiCalls };
}

async function main() {
    console.log('üöÄ Cloudflare R2 ËµÑÊ∫ê‰∏ä‰º†Â∑•ÂÖ∑Ôºà‰ºòÂåñÁâàÔºâ\n');
    
    // Ê£ÄÊü•ÈÖçÁΩÆ
    checkConfig();
    
    console.log('üìã ÈÖçÁΩÆ‰ø°ÊÅØÔºö');
    console.log(`   Account ID: ${config.accountId}`);
    console.log(`   Bucket: ${config.bucketName}`);
    console.log(`   Âº∫Âà∂ÈáçÊñ∞‰∏ä‰º†: ${config.forceUpload ? 'ÊòØ' : 'Âê¶'}`);
    console.log(`   ÁºìÂ≠òÊñá‰ª∂: ${config.cacheFile}`);
    
    // Âä†ËΩΩ‰∏ä‰º†ËÆ∞ÂΩïÁºìÂ≠ò
    const uploadCache = new UploadCache(config.cacheFile);
    
    // ÂàõÂª∫ÂÆ¢Êà∑Á´Ø
    const client = createR2Client();
    console.log('‚úÖ R2 ÂÆ¢Êà∑Á´ØÂàõÂª∫ÊàêÂäü');
    
    // ‰∏ä‰º†ÊâÄÊúâÁõÆÂΩï
    let totalStats = {
        uploaded: 0,
        skippedCache: 0,
        skippedServer: 0,
        failed: 0,
        totalSize: 0,
        apiCalls: 0
    };
    
    for (const dir of config.uploadDirs) {
        if (!fs.existsSync(dir.local)) {
            console.log(`‚ö†Ô∏è  ÁõÆÂΩï‰∏çÂ≠òÂú®ÔºåË∑≥Ëøá: ${dir.local}`);
            continue;
        }
        
        const stats = await uploadDirectory(client, dir.local, dir.remote, uploadCache);
        totalStats.uploaded += stats.uploaded;
        totalStats.skippedCache += stats.skippedCache;
        totalStats.skippedServer += stats.skippedServer;
        totalStats.failed += stats.failed;
        totalStats.totalSize += stats.totalSize;
        totalStats.apiCalls += stats.apiCalls;
    }
    
    // ‰øùÂ≠ò‰∏ä‰º†ËÆ∞ÂΩï
    uploadCache.save();
    
    // ÊòæÁ§∫ÁªüËÆ°
    console.log('\n' + '='.repeat(50));
    console.log('üìä ‰∏ä‰º†ÁªüËÆ°Ôºö');
    console.log(`   ‚úÖ ‰∏ä‰º†ÊàêÂäü: ${totalStats.uploaded} ‰∏™Êñá‰ª∂`);
    console.log(`   ‚ö° ÁºìÂ≠òË∑≥Ëøá: ${totalStats.skippedCache} ‰∏™Êñá‰ª∂`);
    console.log(`   üîÑ ÂêåÊ≠•ËÆ∞ÂΩï: ${totalStats.skippedServer} ‰∏™Êñá‰ª∂`);
    console.log(`   ‚ùå Â§±Ë¥•: ${totalStats.failed} ‰∏™Êñá‰ª∂`);
    console.log(`   üì¶ ÊÄªÂ§ßÂ∞è: ${formatSize(totalStats.totalSize)}`);
    console.log(`   üåê API Ë∞ÉÁî®: ${totalStats.apiCalls} Ê¨°`);
    
    const totalFiles = totalStats.uploaded + totalStats.skippedCache + totalStats.skippedServer + totalStats.failed;
    const savedCalls = totalFiles - totalStats.apiCalls;
    if (savedCalls > 0) {
        console.log(`   ‚ö° ËäÇÁúÅËØ∑Ê±Ç: ${savedCalls} Ê¨° (ÈÄöËøáÊú¨Âú∞ÁºìÂ≠ò)`);
    }
    
    console.log('='.repeat(50));
    
    if (totalStats.failed > 0) {
        console.log('\n‚ö†Ô∏è  ÊúâÊñá‰ª∂‰∏ä‰º†Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÈîôËØØÊó•Âøó');
        process.exit(1);
    } else {
        console.log('\nüéâ ÊâÄÊúâÊñá‰ª∂‰∏ä‰º†ÂÆåÊàêÔºÅ');
        console.log('\nüìù ‰∏ã‰∏ÄÊ≠•Ôºö');
        console.log('1. Âú® Cloudflare R2 ÊéßÂà∂Âè∞‰∏∫ bucket ÈÖçÁΩÆËá™ÂÆö‰πâÂüüÂêçÊàñ‰ΩøÁî® R2.dev ÂüüÂêç');
        console.log('2. Â∞Ü CDN ÂüüÂêçÈÖçÁΩÆÂà∞ proj/src/config/r2-config.js');
        console.log('3. ÈáçÊñ∞ÈÉ®ÁΩ≤Â∫îÁî®Âà∞ Cloudflare Pages');
    }
}

// ËøêË°å‰∏ªÂáΩÊï∞
main().catch(error => {
    console.error('‚ùå ‰∏ä‰º†ËøáÁ®ãÂá∫ÈîôÔºö', error);
    process.exit(1);
});
