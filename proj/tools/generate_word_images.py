#!/usr/bin/env python3
"""
Generate illustrative images for words using SiliconFlow (硅基流动) image API.

- Input words are read from words.csv generated by scan_words.py
- Each word is generated once and saved as a JPEG image
- Results and statuses are persisted in a JSON log next to this script

API key sources (priority):
1) --api-key argument
2) Environment variable SILICONFLOW_API_KEY
3) JSON config/log file at the same path as the log file (apiKey field)

Usage examples:
  python3 generate_word_images.py \
    --limit 50 \
    --model kolors \
    --csv ../words/words.csv \
    --output-dir ../images/generated

  # Initialize or update apiKey in the log JSON
  python3 generate_word_images.py --set-api-key sk-xxxx

  # Set default model into the log JSON
  python3 generate_word_images.py --set-model kolors

  # Generate images for specific words (bypass CSV)
  python3 generate_word_images.py --word apple --word banana --size 300x300
  python3 generate_word_images.py --words "apple;banana;cat"  # 支持分号或逗号分隔

Notes:
- This script requires Pillow for JPEG conversion if the API returns PNG bytes
  pip install pillow
"""

from __future__ import annotations

import argparse
import base64
import csv
import io
import json
import os
import re
import sys
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple

try:
    from PIL import Image  # type: ignore
except Exception:  # pragma: no cover - optional dependency checked at runtime
    Image = None  # type: ignore

import urllib.request


WORD_TOKEN = re.compile(r"^[A-Za-z][A-Za-z\-']+[A-Za-z]$|^[A-Za-z]{2,}$")


@dataclass
class GenerationResult:
    word: str
    image_path: str
    model: str
    created_at: float
    status: str
    error: Optional[str] = None


def read_csv_words(csv_path: Path) -> List[str]:
    words: List[str] = []
    if not csv_path.exists():
        raise FileNotFoundError(f"CSV not found: {csv_path}")

    with csv_path.open("r", encoding="utf-8", newline="") as f:
        reader = csv.reader(f)
        header_processed = False
        for row in reader:
            if not row:
                continue
            # Detect header: expect first row to be [file,count,words]
            if not header_processed and len(row) >= 3 and row[0] == "file" and row[1] == "count" and row[2] == "words":
                header_processed = True
                continue
            header_processed = True

            # Expect: file, count, words(space-separated) or summary rows
            if row[0] == "__summary__":
                break
            words_field = row[2] if len(row) >= 3 else ""
            if words_field:
                words.extend([w.strip() for w in words_field.split(" ") if w.strip()])

    # Deduplicate while preserving order
    seen: Set[str] = set()
    unique: List[str] = []
    for w in words:
        wl = w.lower()
        if wl not in seen:
            seen.add(wl)
            unique.append(wl)
    return unique


def filter_valid_words(words: List[str]) -> List[str]:
    return [w for w in words if WORD_TOKEN.match(w) is not None]


def load_log(log_path: Path) -> Dict[str, dict]:
    if not log_path.exists():
        return {}
    try:
        data = json.loads(log_path.read_text(encoding="utf-8"))
        # Data format: {"apiKey": str, "results": {word: {...}}}
        if isinstance(data, dict) and "results" in data and isinstance(data["results"], dict):
            return data
        return {"results": {}}
    except Exception:
        return {"results": {}}


def save_log(log_path: Path, data: Dict[str, dict]) -> None:
    log_path.parent.mkdir(parents=True, exist_ok=True)
    log_path.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")


def resolve_api_key(cli_key: Optional[str], log_data: Dict[str, dict]) -> Optional[str]:
    if cli_key:
        return cli_key
    env_key = os.getenv("SILICONFLOW_API_KEY")
    if env_key:
        return env_key
    key_in_log = log_data.get("apiKey")
    if isinstance(key_in_log, str) and key_in_log.strip():
        return key_in_log.strip()
    return None


def resolve_model(cli_model: Optional[str], log_data: Dict[str, dict]) -> str:
    if cli_model and cli_model.strip():
        return cli_model.strip()
    model_in_log = log_data.get("model")
    if isinstance(model_in_log, str) and model_in_log.strip():
        return model_in_log.strip()
    # default requirement
    return "kolors"


def http_post_json(url: str, headers: Dict[str, str], payload: dict, timeout: int = 60) -> dict:
    req = urllib.request.Request(url=url, data=json.dumps(payload).encode("utf-8"), headers=headers, method="POST")
    with urllib.request.urlopen(req, timeout=timeout) as resp:
        if resp.status < 200 or resp.status >= 300:
            raise RuntimeError(f"HTTP {resp.status}: {resp.read().decode('utf-8', errors='ignore')}")
        return json.loads(resp.read().decode("utf-8"))


def _download_bytes(url: str, timeout: int = 120) -> bytes:
    with urllib.request.urlopen(url, timeout=timeout) as resp:
        if resp.status < 200 or resp.status >= 300:
            raise RuntimeError(f"HTTP {resp.status} downloading {url}")
        return resp.read()


def generate_image_bytes(
    api_key: str,
    model: str,
    prompt: str,
    size: str = "300x300",
    base_url: str = "https://api.siliconflow.cn",
    endpoint: str = "/v1/images/generations",
    timeout: int = 120,
) -> bytes:
    url = base_url.rstrip("/") + endpoint
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}",
    }
    body = {
        "model": model,
        "prompt": prompt,
        "n": 1,
        "size": size,
        "response_format": "b64_json",
    }
    data = http_post_json(url, headers, body, timeout=timeout)
    # Flexible response handling: prefer b64_json, fallback to url (data or images)
    if isinstance(data, dict):
        if "data" in data and isinstance(data["data"], list) and data["data"]:
            first = data["data"][0]
            if isinstance(first, dict):
                if first.get("b64_json"):
                    return base64.b64decode(first["b64_json"])  # type: ignore[arg-type]
                if first.get("url"):
                    return _download_bytes(first["url"], timeout=timeout)  # type: ignore[arg-type]
        if "images" in data and isinstance(data["images"], list) and data["images"]:
            first_img = data["images"][0]
            if isinstance(first_img, dict) and first_img.get("url"):
                return _download_bytes(first_img["url"], timeout=timeout)  # type: ignore[arg-type]
    raise RuntimeError(f"Unexpected response structure (no b64_json or url): {str(data)[:200]}")


def ensure_jpeg(image_bytes: bytes) -> bytes:
    if Image is None:
        raise RuntimeError("Pillow is required to convert image to JPEG. Install via: pip install pillow")
    with io.BytesIO(image_bytes) as bio:
        with Image.open(bio) as img:
            rgb = img.convert("RGB")
            out = io.BytesIO()
            rgb.save(out, format="JPEG", quality=90)
            return out.getvalue()


def main() -> int:
    script_dir = Path(__file__).resolve().parent
    default_csv = (script_dir.parent / "words" / "words.csv").resolve()
    default_output_dir = (script_dir.parent / "images" / "generated").resolve()
    default_log_path = (script_dir / "generate_word_images.json").resolve()

    parser = argparse.ArgumentParser(description="Generate word images via SiliconFlow")
    parser.add_argument("--csv", type=Path, default=default_csv, help="Path to words.csv")
    parser.add_argument("--output-dir", type=Path, default=default_output_dir, help="Directory to save JPEG images")
    parser.add_argument("--log", type=Path, default=default_log_path, help="Path to JSON log file")
    parser.add_argument("--api-key", type=str, default=None, help="SiliconFlow API key (or use SILICONFLOW_API_KEY env)")
    parser.add_argument("--set-api-key", type=str, default=None, help="Persist apiKey into the log JSON and exit")
    parser.add_argument("--model", type=str, default=None, help="Image generation model id (overrides log JSON)")
    parser.add_argument("--set-model", type=str, default=None, help="Persist default model into the log JSON and exit")
    parser.add_argument("--size", type=str, default="300x300", help="Image size, e.g., 300x300")
    parser.add_argument("--limit", type=int, default=20, help="Max number of words to process in this run")
    parser.add_argument("--delay", type=float, default=1.0, help="Delay seconds between API calls")
    parser.add_argument("--base-url", type=str, default="https://api.siliconflow.cn", help="SiliconFlow base URL")
    parser.add_argument("--endpoint", type=str, default="/v1/images/generations", help="Images generation endpoint path")
    parser.add_argument("--retry", type=int, default=2, help="Number of retries on failure")
    parser.add_argument("--force", action="store_true", help="Force regenerate even if previous result exists")
    parser.add_argument("--words", type=str, default=None, help="Words to generate (bypass CSV), separated by ';' or ','")
    parser.add_argument("--word", action="append", default=None, help="Specify a word (can be repeated)")

    args = parser.parse_args()

    # Load & optionally update log/config
    log_data = load_log(args.log)
    if args.set_api_key:
        log_data["apiKey"] = args.set_api_key.strip()
        if "results" not in log_data:
            log_data["results"] = {}
        save_log(args.log, log_data)
        print(f"[OK] apiKey saved to {args.log}")
        return 0

    if args.set_model:
        log_data["model"] = args.set_model.strip()
        if "results" not in log_data:
            log_data["results"] = {}
        save_log(args.log, log_data)
        print(f"[OK] model saved to {args.log}")
        return 0

    api_key = resolve_api_key(args.api_key, log_data)
    if not api_key:
        print("[ERROR] Missing API key. Provide via --api-key, env SILICONFLOW_API_KEY, or set in log JSON with --set-api-key.")
        return 2

    # Resolve model (JSON -> default 'kolors', or CLI override)
    resolved_model = resolve_model(args.model, log_data)

    # Resolve words from CLI or CSV
    if args.words or args.word:
        cli_words: List[str] = []
        if args.words:
            # Split by semicolon or comma (also accept full-width '；')
            for w in re.split(r"[;,；]", args.words):
                if w.strip():
                    cli_words.append(w.strip())
        if args.word:
            cli_words.extend([w.strip() for w in args.word if w and w.strip()])
        all_words = cli_words
    else:
        all_words = read_csv_words(args.csv)
    valid_words = filter_valid_words(all_words)

    # Prepare existing results
    results_map: Dict[str, dict] = log_data.get("results", {}) if isinstance(log_data.get("results"), dict) else {}

    args.output_dir.mkdir(parents=True, exist_ok=True)

    processed = 0
    for word in valid_words:
        if processed >= args.limit:
            break
        existing = results_map.get(word)
        if not args.force and isinstance(existing, dict) and existing.get("status") == "ok":
            if existing.get("model") == resolved_model and existing.get("size") == args.size:
                continue

        prompt = (
            f"Cartoon-style, child-friendly, high-quality illustration representing the English word '{word}'. "
            f"Plain background, clear and simple composition. "
            f"No text, letters, numbers, watermark, subtitles, or captions in the image. 不要包含任何文字。"
        )
        attempt = 0
        last_exc: Optional[Exception] = None
        while attempt <= max(0, args.retry):
            try:
                raw_bytes = generate_image_bytes(
                    api_key=api_key,
                    model=resolved_model,
                    prompt=prompt,
                    size=args.size,
                    base_url=args.base_url,
                    endpoint=args.endpoint,
                    timeout=120,
                )
                last_exc = None
                break
            except Exception as e:  # noqa: BLE001
                last_exc = e
                attempt += 1
                if attempt > args.retry:
                    break
                time.sleep(min(5.0, 0.5 * (2 ** (attempt - 1))))

        if last_exc is not None:
            results_map[word] = {
                "word": word,
                "image_path": None,
                "model": resolved_model,
                "size": args.size,
                "created_at": time.time(),
                "status": "error",
                "error": str(last_exc),
            }
            print(f"[ERROR] {word}: {last_exc}")
            # Persist after failure
            log_data["apiKey"] = api_key
            log_data["model"] = resolved_model
            log_data["results"] = results_map
            save_log(args.log, log_data)
            time.sleep(max(0.0, args.delay))
            continue

        jpeg_bytes = ensure_jpeg(raw_bytes)
        image_path = args.output_dir / f"{word}.jpg"
        with image_path.open("wb") as f:
            f.write(jpeg_bytes)

        results_map[word] = {
            "word": word,
            "image_path": str(image_path),
            "model": resolved_model,
            "size": args.size,
            "created_at": time.time(),
            "status": "ok",
        }
        processed += 1
        print(f"[OK] {word} -> {image_path}")
        # Persist after success
        log_data["apiKey"] = api_key
        log_data["model"] = resolved_model
        log_data["results"] = results_map
        save_log(args.log, log_data)
        time.sleep(max(0.0, args.delay))

    print(f"[DONE] Processed {processed} word(s). Log saved to {args.log}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())


