#!/usr/bin/env python3
"""
Generate illustrative images for words using SiliconFlow (硅基流动) image API.

- Input words are read from words.csv generated by scan_words.py
- Each word is generated once and saved as a JPEG image
- Configuration is persisted in a JSON file (apiKey/model/promptConstraints/guidance_scale/num_inference_steps/negative_prompt)
- Run-time results and statuses are written to a .log file (not JSON)

API key sources (priority):
1) --api-key argument
2) Environment variable SILICONFLOW_API_KEY
3) JSON config/log file at the same path as the log file (apiKey field)

Usage examples:
  python3 generate_word_images.py \
    --limit 50 \
    --model kolors \
    --csv ../words/words.csv \
    --output-dir ../images/generated

  # Initialize or update apiKey in the log JSON
  python3 generate_word_images.py --set-api-key sk-xxxx

  # Set default model into the log JSON
  python3 generate_word_images.py --set-model kolors

  # Set generation parameters into the log JSON
  python3 generate_word_images.py --set-guidance-scale 7.5
  python3 generate_word_images.py --set-inference-steps 20
  python3 generate_word_images.py --set-negative-prompt "blurry, low quality"

  # Generate images for specific words (bypass CSV)
  python3 generate_word_images.py --word apple --word banana --size 300x300
  python3 generate_word_images.py --words "apple;banana;cat"  # 支持分号或逗号分隔

  # Override parameters for a single run (without saving to JSON)
  python3 generate_word_images.py --word apple --guidance-scale 4.0 --inference-steps 20

Notes:
- This script requires Pillow for JPEG conversion if the API returns PNG bytes
  pip install pillow
"""

from __future__ import annotations

import argparse
import base64
import csv
import io
import json
import os
import re
import sys
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple

try:
    from PIL import Image  # type: ignore
except Exception:  # pragma: no cover - optional dependency checked at runtime
    Image = None  # type: ignore

import urllib.request


WORD_TOKEN = re.compile(r"^[A-Za-z][A-Za-z\-']+[A-Za-z]$|^[A-Za-z]{2,}$")


@dataclass
class GenerationResult:
    word: str
    image_path: str
    model: str
    created_at: float
    status: str
    error: Optional[str] = None


def read_csv_words(csv_path: Path) -> List[str]:
    words: List[str] = []
    if not csv_path.exists():
        raise FileNotFoundError(f"CSV not found: {csv_path}")

    with csv_path.open("r", encoding="utf-8", newline="") as f:
        reader = csv.reader(f)
        header_processed = False
        for row in reader:
            if not row:
                continue
            # Detect header: expect first row to be [file,count,words]
            if not header_processed and len(row) >= 3 and row[0] == "file" and row[1] == "count" and row[2] == "words":
                header_processed = True
                continue
            header_processed = True

            # Expect: file, count, words(space-separated) or summary rows
            if row[0] == "__summary__":
                break
            words_field = row[2] if len(row) >= 3 else ""
            if words_field:
                words.extend([w.strip() for w in words_field.split(" ") if w.strip()])

    # Deduplicate while preserving order
    seen: Set[str] = set()
    unique: List[str] = []
    for w in words:
        wl = w.lower()
        if wl not in seen:
            seen.add(wl)
            unique.append(wl)
    return unique


def filter_valid_words(words: List[str]) -> List[str]:
    return [w for w in words if WORD_TOKEN.match(w) is not None]


def load_config(config_path: Path) -> Dict[str, dict]:
    if not config_path.exists():
        return {}
    try:
        data = json.loads(config_path.read_text(encoding="utf-8"))
        # Expected keys: apiKey, model, promptConstraints
        return data if isinstance(data, dict) else {}
    except Exception:
        return {}


def save_config(config_path: Path, data: Dict[str, dict]) -> None:
    config_path.parent.mkdir(parents=True, exist_ok=True)
    config_path.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")


def clear_log(log_file: Path) -> None:
    """Clear the log file at the start of a new run."""
    log_file.parent.mkdir(parents=True, exist_ok=True)
    if log_file.exists():
        log_file.unlink()


def append_log(log_file: Path, entry: Dict[str, object]) -> None:
    log_file.parent.mkdir(parents=True, exist_ok=True)
    # Write JSON line with timestamp
    entry_with_ts = {"ts": time.time(), **entry}
    with log_file.open("a", encoding="utf-8") as f:
        f.write(json.dumps(entry_with_ts, ensure_ascii=False) + "\n")


def init_csv_log(csv_file: Path) -> None:
    """Initialize CSV log file with header."""
    csv_file.parent.mkdir(parents=True, exist_ok=True)
    with csv_file.open("w", encoding="utf-8", newline="") as f:
        writer = csv.writer(f)
        writer.writerow([
            "word",
            "complete_prompt"
        ])


def append_csv_log(csv_file: Path, entry: Dict[str, object]) -> None:
    """Append a generation record to CSV log."""
    with csv_file.open("a", encoding="utf-8", newline="") as f:
        writer = csv.writer(f)
        writer.writerow([
            entry.get("word", ""),
            entry.get("complete_prompt", "")
        ])


def resolve_api_key(cli_key: Optional[str], log_data: Dict[str, dict]) -> Optional[str]:
    if cli_key:
        return cli_key
    env_key = os.getenv("SILICONFLOW_API_KEY")
    if env_key:
        return env_key
    key_in_log = log_data.get("apiKey")
    if isinstance(key_in_log, str) and key_in_log.strip():
        return key_in_log.strip()
    return None


def resolve_model(cli_model: Optional[str], log_data: Dict[str, dict]) -> str:
    if cli_model and cli_model.strip():
        return cli_model.strip()
    model_in_log = log_data.get("model")
    if isinstance(model_in_log, str) and model_in_log.strip():
        return model_in_log.strip()
    # default requirement
    return "kolors"


def resolve_prompt_constraints(cli_prompt: Optional[str], log_data: Dict[str, dict]) -> str:
    """Resolve prompt constraints/prefix from CLI or JSON.

    - If CLI provided, use it
    - Else if JSON has 'promptConstraints', use it
    - Else fallback to a sensible default that enforces cartoon/no-text style
    """
    if cli_prompt and cli_prompt.strip():
        return cli_prompt.strip()
    prompt_in_log = log_data.get("promptConstraints")
    if isinstance(prompt_in_log, str) and prompt_in_log.strip():
        return prompt_in_log.strip()
    # Default constraints
    return (
        "Cartoon-style, child-friendly, high-quality illustration. Plain background, clear and simple composition. "
        "No text, letters, numbers, watermark, subtitles, or captions in the image. 不要包含任何文字。"
    )


def resolve_guidance_scale(cli_guidance: Optional[float], log_data: Dict[str, dict]) -> float:
    """Resolve guidance_scale (cfg) from CLI or JSON.
    
    - If CLI provided, use it
    - Else if JSON has 'guidance_scale', use it
    - Else fallback to default value 7.5
    """
    if cli_guidance is not None:
        return cli_guidance
    guidance_in_log = log_data.get("guidance_scale")
    if isinstance(guidance_in_log, (int, float)):
        return float(guidance_in_log)
    return 7.5


def resolve_inference_steps(cli_steps: Optional[int], log_data: Dict[str, dict]) -> int:
    """Resolve num_inference_steps from CLI or JSON.
    
    - If CLI provided, use it
    - Else if JSON has 'num_inference_steps', use it
    - Else fallback to default value 20
    """
    if cli_steps is not None:
        return cli_steps
    steps_in_log = log_data.get("num_inference_steps")
    if isinstance(steps_in_log, int):
        return steps_in_log
    return 20


def resolve_negative_prompt(cli_negative: Optional[str], log_data: Dict[str, dict]) -> str:
    """Resolve negative_prompt from CLI or JSON.
    
    - If CLI provided, use it
    - Else if JSON has 'negative_prompt', use it
    - Else fallback to empty string
    """
    if cli_negative and cli_negative.strip():
        return cli_negative.strip()
    negative_in_log = log_data.get("negative_prompt")
    if isinstance(negative_in_log, str) and negative_in_log.strip():
        return negative_in_log.strip()
    return ""


def http_post_json(url: str, headers: Dict[str, str], payload: dict, timeout: int = 60) -> dict:
    req = urllib.request.Request(url=url, data=json.dumps(payload).encode("utf-8"), headers=headers, method="POST")
    with urllib.request.urlopen(req, timeout=timeout) as resp:
        if resp.status < 200 or resp.status >= 300:
            raise RuntimeError(f"HTTP {resp.status}: {resp.read().decode('utf-8', errors='ignore')}")
        return json.loads(resp.read().decode("utf-8"))


def _download_bytes(url: str, timeout: int = 120) -> bytes:
    with urllib.request.urlopen(url, timeout=timeout) as resp:
        if resp.status < 200 or resp.status >= 300:
            raise RuntimeError(f"HTTP {resp.status} downloading {url}")
        return resp.read()


def generate_image_bytes(
    api_key: str,
    model: str,
    prompt: str,
    size: str = "300x300",
    guidance_scale: float = 7.5,
    num_inference_steps: int = 20,
    negative_prompt: str = "",
    base_url: str = "https://api.siliconflow.cn",
    endpoint: str = "/v1/images/generations",
    timeout: int = 120,
) -> bytes:
    url = base_url.rstrip("/") + endpoint
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}",
    }
    body = {
        "model": model,
        "prompt": prompt,
        "n": 1,
        "size": size,
        "response_format": "b64_json",
        "guidance_scale": guidance_scale,
        "num_inference_steps": num_inference_steps,
    }
    # Only add negative_prompt if it's not empty
    if negative_prompt:
        body["negative_prompt"] = negative_prompt
    data = http_post_json(url, headers, body, timeout=timeout)
    # Flexible response handling: prefer b64_json, fallback to url (data or images)
    if isinstance(data, dict):
        if "data" in data and isinstance(data["data"], list) and data["data"]:
            first = data["data"][0]
            if isinstance(first, dict):
                if first.get("b64_json"):
                    return base64.b64decode(first["b64_json"])  # type: ignore[arg-type]
                if first.get("url"):
                    return _download_bytes(first["url"], timeout=timeout)  # type: ignore[arg-type]
        if "images" in data and isinstance(data["images"], list) and data["images"]:
            first_img = data["images"][0]
            if isinstance(first_img, dict) and first_img.get("url"):
                return _download_bytes(first_img["url"], timeout=timeout)  # type: ignore[arg-type]
    raise RuntimeError(f"Unexpected response structure (no b64_json or url): {str(data)[:200]}")


def ensure_jpeg(image_bytes: bytes) -> bytes:
    if Image is None:
        raise RuntimeError("Pillow is required to convert image to JPEG. Install via: pip install pillow")
    with io.BytesIO(image_bytes) as bio:
        with Image.open(bio) as img:
            rgb = img.convert("RGB")
            out = io.BytesIO()
            rgb.save(out, format="JPEG", quality=90)
            return out.getvalue()


def main() -> int:
    script_dir = Path(__file__).resolve().parent
    default_csv = (script_dir.parent / "words" / "words.csv").resolve()
    default_output_dir = (script_dir.parent / "images" / "generated").resolve()
    default_config_path = (script_dir / "generate_word_images.json").resolve()
    default_log_file = (script_dir / "generate_word_images.log").resolve()
    default_csv_log = (script_dir / "generate_word_images_records.csv").resolve()

    parser = argparse.ArgumentParser(description="Generate word images via SiliconFlow")
    parser.add_argument("--csv", type=Path, default=default_csv, help="Path to words.csv")
    parser.add_argument("--output-dir", type=Path, default=default_output_dir, help="Directory to save JPEG images")
    parser.add_argument("--log", type=Path, default=default_config_path, help="Path to JSON config file (apiKey/model/promptConstraints)")
    parser.add_argument("--log-file", type=Path, default=default_log_file, help="Path to .log file for run-time statuses")
    parser.add_argument("--csv-log", type=Path, default=default_csv_log, help="Path to CSV log file for generation records")
    parser.add_argument("--api-key", type=str, default=None, help="SiliconFlow API key (or use SILICONFLOW_API_KEY env)")
    parser.add_argument("--set-api-key", type=str, default=None, help="Persist apiKey into the log JSON and exit")
    parser.add_argument("--model", type=str, default=None, help="Image generation model id (overrides log JSON)")
    parser.add_argument("--set-model", type=str, default=None, help="Persist default model into the log JSON and exit")
    parser.add_argument("--size", type=str, default="300x300", help="Image size, e.g., 300x300")
    parser.add_argument("--limit", type=int, default=20, help="Max number of words to process in this run")
    parser.add_argument("--delay", type=float, default=1.0, help="Delay seconds between API calls")
    parser.add_argument("--base-url", type=str, default="https://api.siliconflow.cn", help="SiliconFlow base URL")
    parser.add_argument("--endpoint", type=str, default="/v1/images/generations", help="Images generation endpoint path")
    parser.add_argument("--retry", type=int, default=2, help="Number of retries on failure")
    parser.add_argument("--force", action="store_true", help="Force regenerate even if previous result exists")
    parser.add_argument("--prompt", type=str, default=None, help="Prompt constraints template, supports {word}")
    parser.add_argument("--set-prompt", type=str, default=None, help="Persist prompt constraints into the log JSON and exit")
    parser.add_argument("--guidance-scale", type=float, default=None, help="Guidance scale (cfg), e.g., 7.5 (overrides log JSON)")
    parser.add_argument("--set-guidance-scale", type=float, default=None, help="Persist guidance_scale into the log JSON and exit")
    parser.add_argument("--inference-steps", type=int, default=None, help="Number of inference steps, e.g., 20 (overrides log JSON)")
    parser.add_argument("--set-inference-steps", type=int, default=None, help="Persist num_inference_steps into the log JSON and exit")
    parser.add_argument("--negative-prompt", type=str, default=None, help="Negative prompt text (overrides log JSON)")
    parser.add_argument("--set-negative-prompt", type=str, default=None, help="Persist negative_prompt into the log JSON and exit")
    parser.add_argument("--words", type=str, default=None, help="Words to generate (bypass CSV), separated by ';' or ','")
    parser.add_argument("--word", action="append", default=None, help="Specify a word (can be repeated)")

    args = parser.parse_args()

    # Load & optionally update log/config
    log_data = load_config(args.log)
    if args.set_api_key:
        log_data["apiKey"] = args.set_api_key.strip()
        save_config(args.log, log_data)
        print(f"[OK] apiKey saved to {args.log}")
        return 0

    if args.set_model:
        log_data["model"] = args.set_model.strip()
        save_config(args.log, log_data)
        print(f"[OK] model saved to {args.log}")
        return 0

    if args.set_prompt:
        log_data["promptConstraints"] = args.set_prompt.strip()
        save_config(args.log, log_data)
        print(f"[OK] promptConstraints saved to {args.log}")
        return 0

    if args.set_guidance_scale is not None:
        log_data["guidance_scale"] = args.set_guidance_scale
        save_config(args.log, log_data)
        print(f"[OK] guidance_scale saved to {args.log}")
        return 0

    if args.set_inference_steps is not None:
        log_data["num_inference_steps"] = args.set_inference_steps
        save_config(args.log, log_data)
        print(f"[OK] num_inference_steps saved to {args.log}")
        return 0

    if args.set_negative_prompt is not None:
        log_data["negative_prompt"] = args.set_negative_prompt.strip()
        save_config(args.log, log_data)
        print(f"[OK] negative_prompt saved to {args.log}")
        return 0

    api_key = resolve_api_key(args.api_key, log_data)
    if not api_key:
        print("[ERROR] Missing API key. Provide via --api-key, env SILICONFLOW_API_KEY, or set in log JSON with --set-api-key.")
        return 2

    # Resolve model (JSON -> default 'kolors', or CLI override)
    resolved_model = resolve_model(args.model, log_data)
    # Resolve prompt constraints (JSON -> default cartoon/no-text, or CLI override)
    prompt_template = resolve_prompt_constraints(args.prompt, log_data)
    # Resolve guidance_scale (JSON -> default 7.5, or CLI override)
    guidance_scale = resolve_guidance_scale(args.guidance_scale, log_data)
    # Resolve num_inference_steps (JSON -> default 20, or CLI override)
    num_inference_steps = resolve_inference_steps(args.inference_steps, log_data)
    # Resolve negative_prompt (JSON -> default empty, or CLI override)
    negative_prompt = resolve_negative_prompt(args.negative_prompt, log_data)

    # Resolve words from CLI or CSV
    if args.words or args.word:
        cli_words: List[str] = []
        if args.words:
            # Split by semicolon or comma (also accept full-width '；')
            for w in re.split(r"[;,；]", args.words):
                if w.strip():
                    cli_words.append(w.strip())
        if args.word:
            cli_words.extend([w.strip() for w in args.word if w and w.strip()])
        all_words = cli_words
    else:
        all_words = read_csv_words(args.csv)
    valid_words = filter_valid_words(all_words)

    args.output_dir.mkdir(parents=True, exist_ok=True)

    # Clear old logs and initialize new ones
    clear_log(args.log_file)
    init_csv_log(args.csv_log)
    print(f"[INFO] Cleared old logs, starting new run")

    processed = 0
    for word in valid_words:
        if processed >= args.limit:
            break
        image_path = args.output_dir / f"{word}.jpg"
        if not args.force and image_path.exists():
            # Skip if file exists and not forcing
            continue

        # Compose final prompt:
        # - If template contains {word}, replace it
        # - Otherwise, append a clear instruction about the specific word
        if "{word}" in prompt_template:
            prompt = prompt_template.replace("{word}", word)
        else:
            prompt = f"{prompt_template} Represent the English word '{word}'."
        attempt = 0
        last_exc: Optional[Exception] = None
        while attempt <= max(0, args.retry):
            try:
                raw_bytes = generate_image_bytes(
                    api_key=api_key,
                    model=resolved_model,
                    prompt=prompt,
                    size=args.size,
                    guidance_scale=guidance_scale,
                    num_inference_steps=num_inference_steps,
                    negative_prompt=negative_prompt,
                    base_url=args.base_url,
                    endpoint=args.endpoint,
                    timeout=120,
                )
                last_exc = None
                break
            except Exception as e:  # noqa: BLE001
                last_exc = e
                attempt += 1
                if attempt > args.retry:
                    break
                time.sleep(min(5.0, 0.5 * (2 ** (attempt - 1))))

        if last_exc is not None:
            print(f"[ERROR] {word}: {last_exc}")
            # 创建完整的提示词（可直接复制到其他 AI 软件使用）
            complete_prompt = f"生成单词对应图片: {word}\n\nPrompt: {prompt}\n\nNegative Prompt: {negative_prompt}"
            error_entry = {
                "ts": time.time(),
                "word": word,
                "status": "error",
                "complete_prompt": complete_prompt,
                "model": resolved_model,
                "size": args.size,
                "guidance_scale": guidance_scale,
                "num_inference_steps": num_inference_steps,
                "prompt": prompt,
                "negative_prompt": negative_prompt,
                "error": str(last_exc),
            }
            append_log(args.log_file, error_entry)
            append_csv_log(args.csv_log, error_entry)
            time.sleep(max(0.0, args.delay))
            continue

        jpeg_bytes = ensure_jpeg(raw_bytes)
        with image_path.open("wb") as f:
            f.write(jpeg_bytes)

        # 创建完整的提示词（可直接复制到其他 AI 软件使用）
        complete_prompt = f"生成单词对应图片: {word}\n\nPrompt: {prompt}\n\nNegative Prompt: {negative_prompt}"
        success_entry = {
            "ts": time.time(),
            "word": word,
            "status": "ok",
            "complete_prompt": complete_prompt,
            "image_path": str(image_path),
            "model": resolved_model,
            "size": args.size,
            "guidance_scale": guidance_scale,
            "num_inference_steps": num_inference_steps,
            "prompt": prompt,
            "negative_prompt": negative_prompt,
        }
        append_log(args.log_file, success_entry)
        append_csv_log(args.csv_log, success_entry)
        processed += 1
        print(f"[OK] {word} -> {image_path}")
        time.sleep(max(0.0, args.delay))

    print(f"[DONE] Processed {processed} word(s)")
    print(f"[INFO] JSON log: {args.log_file}")
    print(f"[INFO] CSV log: {args.csv_log}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())


