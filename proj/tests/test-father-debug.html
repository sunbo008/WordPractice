<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æµ‹è¯• father</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 40px;
            background: #1e3c72;
            color: white;
        }
        .word {
            font-size: 64px;
            margin: 20px 0;
        }
        .stress { color: #ff4444; font-weight: bold; }
        .normal { color: #ffffff; }
        .debug {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <h1>æµ‹è¯• father é‡éŸ³è¯†åˆ«</h1>
    
    <div class="debug">
        <h3>å•è¯ä¿¡æ¯</h3>
        <p><strong>å•è¯:</strong> father</p>
        <p><strong>éŸ³æ ‡:</strong> [ËˆfÉ‘ËÃ°É™]</p>
        <p><strong>é‡éŸ³ç¬¦å·:</strong> Ëˆ åœ¨å¼€å¤?/p>
        <p><strong>é¢„æœŸé‡éŸ³:</strong> fa (ç¬¬ä¸€éŸ³èŠ‚)</p>
    </div>
    
    <div class="word" id="result"></div>
    
    <div class="debug" id="analysis"></div>
    
    <script>
        // ä»?vocabulary-manager-v2.js å¤åˆ¶çš„ç®—æ³?
        function getStressPositions(word, phonetic) {
            console.log('=== åˆ†æ father ===');
            console.log('å•è¯:', word);
            console.log('éŸ³æ ‡:', phonetic);
            
            const lowerWord = word.toLowerCase();
            
            // æŸ¥æ‰¾é‡éŸ³ç¬¦å·
            const stressPattern = /[ËˆËŒ]([É™Ã¦É‘É’É”ÉªiËÉœÉ›eÊŠuËÊŒÉ”ËÉªÉ™eÉªaÉªÉ”ÉªÉ™ÊŠeÉ™ÉªÉ™ÊŠÉ™aÊŠ]+)/g;
            const matches = [];
            let match;
            
            while ((match = stressPattern.exec(phonetic)) !== null) {
                matches.push({
                    index: match.index,
                    vowelSound: match[1],
                    type: phonetic[match.index]
                });
                console.log('æ‰¾åˆ°é‡éŸ³:', phonetic[match.index], match[1], 'ä½ç½®:', match.index);
            }
            
            if (matches.length === 0) {
                console.log('âš ï¸ æ²¡æœ‰æ‰¾åˆ°é‡éŸ³ç¬¦å·');
                return [];
            }
            
            console.log('æ‰¾åˆ°', matches.length, 'ä¸ªé‡éŸ³ç¬¦å?);
            
            // ä¼˜å…ˆä¸»é‡éŸ?
            const primaryStress = matches.filter(m => m.type === 'Ëˆ');
            const stressesToProcess = primaryStress.length > 0 ? primaryStress : matches;
            
            console.log('å¤„ç†é‡éŸ³æ•°é‡:', stressesToProcess.length);
            
            const result = [];
            const vowels = 'aeiou';
            
            stressesToProcess.forEach((stressMatch, idx) => {
                console.log(`\nå¤„ç†é‡éŸ³ ${idx + 1}:`);
                const beforeStress = phonetic.substring(0, stressMatch.index);
                console.log('  é‡éŸ³å‰çš„éŸ³æ ‡:', beforeStress);
                
                const syllablesBefore = (beforeStress.match(/[É™Ã¦É‘É’É”ÉªiËÉœÉ›eÊŠuËÊŒÉ”ËaÊŠ]+/g) || []).length;
                console.log('  é‡éŸ³å‰çš„éŸ³èŠ‚æ•?', syllablesBefore);
                
                console.log('  åœ¨å•è¯ä¸­æŸ¥æ‰¾ç¬?, syllablesBefore, 'ä¸ªå…ƒéŸ?);
                let vowelCount = 0;
                for (let i = 0; i < lowerWord.length; i++) {
                    if (vowels.includes(lowerWord[i])) {
                        console.log(`    å…ƒéŸ³ ${vowelCount}: ${lowerWord[i]} at ${i}`);
                        if (vowelCount === syllablesBefore) {
                            console.log(`    âœ?åŒ¹é…ï¼æ‰¾åˆ°é‡éŸ³å…ƒéŸ³`);
                            
                            // æ‰©å±•ä¸ºæ•´ä¸ªéŸ³èŠ?
                            const syllable = getWholeSyllable(lowerWord, i);
                            console.log('    éŸ³èŠ‚èŒƒå›´:', syllable, 'â†?, syllable.map(idx => lowerWord[idx]).join(''));
                            
                            syllable.forEach(pos => {
                                if (!result.includes(pos)) {
                                    result.push(pos);
                                }
                            });
                            break;
                        }
                        vowelCount++;
                    }
                }
            });
            
            console.log('\næœ€ç»ˆç»“æ?', result, 'â†?, result.map(i => lowerWord[i]).join(''));
            return result.sort((a, b) => a - b);
        }
        
        function getWholeSyllable(word, vowelIndex) {
            console.log('    æ‰©å±•éŸ³èŠ‚ï¼Œä»å…ƒéŸ³ç´¢å¼•', vowelIndex, '(', word[vowelIndex], ')');
            const vowels = 'aeiou';
            const result = [];
            
            let centerVowel = vowelIndex;
            
            // å‘å·¦æ‰©å±•
            let left = centerVowel;
            let consonantsBeforeCount = 0;
            let tempLeft = left - 1;
            while (tempLeft >= 0 && !vowels.includes(word[tempLeft])) {
                consonantsBeforeCount++;
                tempLeft--;
            }
            console.log('    å‰é¢æœ?, consonantsBeforeCount, 'ä¸ªè¾…éŸ?);
            
            if (tempLeft >= 0) {
                if (consonantsBeforeCount === 1) {
                    left = left - 1;
                    console.log('    å•ä¸ªè¾…éŸ³ï¼ŒåŒ…å?', word[left]);
                } else if (consonantsBeforeCount >= 2) {
                    left = left - Math.ceil(consonantsBeforeCount / 2);
                    console.log('    å¤šä¸ªè¾…éŸ³ï¼Œå–åä¸€å?);
                }
            } else {
                left = 0;
                console.log('    å•è¯å¼€å¤´ï¼Œå–æ‰€æœ?);
            }
            
            // å‘å³æ‰©å±•
            let right = centerVowel;
            while (right < word.length - 1 && vowels.includes(word[right + 1])) {
                right++;
            }
            
            let consonantsAfterCount = 0;
            let tempRight = right;
            while (tempRight < word.length - 1 && !vowels.includes(word[tempRight + 1])) {
                consonantsAfterCount++;
                tempRight++;
            }
            console.log('    åé¢æœ?, consonantsAfterCount, 'ä¸ªè¾…éŸ?);
            
            if (tempRight < word.length - 1) {
                if (consonantsAfterCount >= 2) {
                    right += Math.floor(consonantsAfterCount / 2);
                }
            } else {
                right = tempRight;
            }
            
            console.log('    å·¦è¾¹ç•?', left, 'å³è¾¹ç•?', right);
            
            for (let i = left; i <= right && i < word.length; i++) {
                result.push(i);
            }
            
            return result;
        }
        
        // æµ‹è¯•
        const word = 'father';
        const phonetic = '[ËˆfÉ‘ËÃ°É™]';
        const positions = getStressPositions(word, phonetic);
        
        // æ˜¾ç¤ºç»“æœ
        let resultHtml = '<div>';
        for (let i = 0; i < word.length; i++) {
            if (positions.includes(i)) {
                resultHtml += `<span class="stress">${word[i]}</span>`;
            } else {
                resultHtml += `<span class="normal">${word[i]}</span>`;
            }
        }
        resultHtml += '</div>';
        resultHtml += `<p style="font-size: 20px;">è¯†åˆ«ä½ç½®: [${positions.join(', ')}] â†?"${positions.map(i => word[i]).join('')}"</p>`;
        resultHtml += `<p style="font-size: 20px;">é¢„æœŸä½ç½®: [0, 1, 2] â†?"fath"ï¼ˆfa+åŠä¸ªthï¼?/p>`;
        
        document.getElementById('result').innerHTML = resultHtml;
        
        // åˆ†æ
        let analysis = '<h3>è¯¦ç»†åˆ†æ</h3>';
        analysis += '<p><strong>father éŸ³èŠ‚åˆ’åˆ†:</strong> fa-ther</p>';
        analysis += '<p><strong>é‡éŸ³ç¬¦å· Ëˆ ä½ç½®:</strong> åœ¨éŸ³æ ‡å¼€å¤´ï¼ˆ[ËˆfÉ‘ËÃ°É™]ï¼?/p>';
        analysis += '<p><strong>è®¡ç®—è¿‡ç¨‹:</strong></p>';
        analysis += '<ul>';
        analysis += '<li>é‡éŸ³ç¬¦å·å‰çš„éŸ³æ ‡: "["ï¼ˆåªæœ‰æ‹¬å·ï¼Œæ²¡æœ‰å…ƒéŸ³ï¼?/li>';
        analysis += '<li>å‰é¢çš„éŸ³èŠ‚æ•°: 0</li>';
        analysis += '<li>åœ¨å•è¯ä¸­æŸ¥æ‰¾ç¬?0 ä¸ªå…ƒéŸ? f[a]therï¼ˆç´¢å¼?å¤„æ²¡æœ‰å…ƒéŸ³ï¼ï¼?/li>';
        analysis += '<li>ç¬?0 ä¸ªå…ƒéŸ³åº”è¯¥æ˜¯ "a"ï¼ˆç´¢å¼?ï¼?/li>';
        analysis += '</ul>';
        analysis += '<p><strong>é—®é¢˜:</strong> éŸ³æ ‡ä»?[Ëˆf... å¼€å¤´ï¼Œç®—æ³•è®¡ç®—å‰é¢æœ?ä¸ªéŸ³èŠ‚ï¼Œåº”è¯¥æŸ¥æ‰¾å•è¯çš„ç¬¬0ä¸ªå…ƒéŸ³ï¼ˆä»ç´¢å¼?å¼€å§‹çš„ç¬¬ä¸€ä¸ªå…ƒéŸ³ï¼‰</p>';
        
        document.getElementById('analysis').innerHTML = analysis;
    </script>
</body>
</html>

