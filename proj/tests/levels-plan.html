<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç­‰çº§è¯è¡¨è§„åˆ’æµ‹è¯• - Word Tetris</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'PingFang SC', 'Microsoft YaHei', sans-serif; margin: 20px; color: #2c3e50; }
        h1 { margin: 0 0 10px; }
        .desc { color: #7f8c8d; margin-bottom: 20px; }
        .summary { display: flex; flex-wrap: wrap; gap: 12px; margin: 10px 0 20px; }
        .card { background:#f8f9fa; border:1px solid #e9ecef; border-radius:8px; padding:12px 16px; min-width: 180px; }
        .ok { color:#27ae60; }
        .warn { color:#e67e22; }
        .error { color:#c0392b; }
        .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap:16px; }
        .panel { border:1px solid #e9ecef; border-radius:10px; }
        .panel h3 { margin:0; padding:10px 12px; background:#f4f6f8; border-bottom:1px solid #e9ecef; }
        .panel .body { padding:12px; }
        details > summary { cursor: pointer; user-select: none; }
        ul.words { list-style: none; padding: 0; margin:0; display:flex; flex-wrap:wrap; gap:6px; }
        ul.words li { background:#fff; border:1px solid #e9ecef; border-radius:6px; padding:6px 8px; }
        table { width:100%; border-collapse: collapse; }
        th, td { border:1px solid #e9ecef; padding:8px; text-align:left; }
        th { background:#f8f9fa; }
        .muted { color:#95a5a6; }
        .badge { display:inline-block; padding:2px 6px; font-size:12px; border-radius:4px; background:#ecf0f1; color:#34495e; }
    </style>
</head>
<body>
    <h1>ç­‰çº§è¯è¡¨è§„åˆ’æµ‹è¯•</h1>
    <div class="desc">éªŒè¯â€œåŒä¸€å•è¯åªå‡ºç°äºä¸€ä¸ªç­‰çº§â€ï¼Œå¹¶å±•ç¤ºå„ç­‰çº§è¯è¡¨ä¸é‡å¤æ¥æºã€?/div>

    <div id="summary" class="summary"></div>

    <div class="panel" style="margin-bottom:16px;">
        <h3>é‡å¤è¯æ¥æºï¼ˆè¢«è¿‡æ»¤ï¼‰</h3>
        <div class="body" id="duplicates">
            <div class="muted">åŠ è½½ä¸?..</div>
        </div>
    </div>

    <div class="grid" id="levels"></div>

    <script src="../src/core/vocabulary-config-loader.js?v=20251007-levels"></script>
    <script src="../src/core/vocabulary-manager-v2.js?v=20251007-levels"></script>
    <script>
    (async function() {
        const vm = new VocabularyManagerV2();

        // ç­‰å¾…å¼‚æ­¥åŠ è½½å®Œæˆ
        function waitLoaded() {
            return new Promise(resolve => {
                const timer = setInterval(() => {
                    if (vm.isLoaded || vm.loadError) {
                        clearInterval(timer);
                        resolve();
                    }
                }, 50);
            });
        }
        await waitLoaded();

        const summaryEl = document.getElementById('summary');
        const levelsEl = document.getElementById('levels');
        const dupEl = document.getElementById('duplicates');

        if (vm.loadError) {
            summaryEl.innerHTML = '<div class="card error">è¯åº“åŠ è½½å¤±è´¥</div>';
            return;
        }

        // è·å–åˆ†ç»„ä¸ç»Ÿè®?
        const grouped = vm.getWordsGroupedByDifficulty();
        const planSummary = vm.getLevelPlanSummary();
        const duplicates = vm.getFilteredDuplicateWords();

        // å»é‡æ ¡éªŒï¼šåŒä¸€ä¸ªå•è¯æ˜¯å¦å‡ºç°åœ¨å¤šä¸ªç­‰çº§
        const wordToDiffs = new Map();
        Object.entries(grouped).forEach(([diff, list]) => {
            list.forEach(item => {
                if (!wordToDiffs.has(item.word)) wordToDiffs.set(item.word, new Set());
                wordToDiffs.get(item.word).add(Number(diff));
            });
        });
        const crossLevelConflicts = [];
        for (const [w, diffs] of wordToDiffs.entries()) {
            if (diffs.size > 1) crossLevelConflicts.push({ word: w, diffs: Array.from(diffs).sort() });
        }

        // æ¦‚è§ˆ
        const totalWords = Object.values(grouped).reduce((s, arr) => s + arr.length, 0);
        const diffCount = Object.keys(grouped).length;
        const dupCount = duplicates.length;
        const conflictCount = crossLevelConflicts.length;

        summaryEl.innerHTML = `
            <div class="card"><div>æ€»å•è¯æ•°</div><div><strong>${totalWords}</strong></div></div>
            <div class="card"><div>ç­‰çº§æ•°é‡</div><div><strong>${diffCount}</strong></div></div>
            <div class="card ${conflictCount === 0 ? 'ok' : 'error'}"><div>è·¨ç­‰çº§é‡å¤?/div><div><strong>${conflictCount}</strong></div></div>
            <div class="card ${dupCount === 0 ? 'ok' : 'warn'}"><div>è·¨åº“é‡å¤ï¼ˆå·²è¿‡æ»¤ï¼?/div><div><strong>${dupCount}</strong></div></div>
        `;

        // é‡å¤æ¥æºè¡?
        if (dupCount === 0) {
            dupEl.innerHTML = '<div class="ok">æœªå‘ç°è·¨åº“é‡å¤è¯</div>';
        } else {
            const rows = duplicates.slice(0, 200).map(d => {
                const libA = (d.libraries && d.libraries[0]) || '';
                const libB = (d.libraries && d.libraries[1]) || '';
                const lesA = (d.lessons && d.lessons[0]) || '';
                const lesB = (d.lessons && d.lessons[1]) || '';
                return `<tr><td>${d.word}</td><td><span class="badge">${libA}</span> / <span class="badge">${lesA}</span></td><td><span class="badge">${libB}</span> / <span class="badge">${lesB}</span></td></tr>`;
            }).join('');
            dupEl.innerHTML = `
                <details open>
                    <summary>é‡å¤ ${dupCount} é¡¹ï¼ˆæ˜¾ç¤ºå‰?00ï¼?/summary>
                    <div style="margin-top:8px;">
                        <table>
                            <thead><tr><th>å•è¯</th><th>æ¥æº1</th><th>æ¥æº2</th></tr></thead>
                            <tbody>${rows}</tbody>
                        </table>
                    </div>
                </details>
            `;
        }

        // å„ç­‰çº§é¢æ?
        levelsEl.innerHTML = planSummary.map(s => {
            const list = grouped[s.difficulty] || [];
            const items = list.map(w => `<li title="${w.meaning}">${w.word}</li>`).join('');
            return `
                <div class="panel">
                    <h3>éš¾åº¦ ${s.difficulty}ï¼?{s.count}ï¼?/h3>
                    <div class="body">
                        <ul class="words">${items}</ul>
                    </div>
                </div>
            `;
        }).join('');
    })();
    </script>
</body>
</html>




