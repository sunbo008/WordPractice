<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>è°ƒè¯• about</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            padding: 40px;
            background: #1e3c72;
            color: white;
            line-height: 1.8;
        }
        .word {
            font-size: 64px;
            margin: 20px 0;
        }
        .stress { color: #ff4444; font-weight: bold; }
        .normal { color: #ffffff; }
        .debug {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 14px;
        }
        .step {
            background: rgba(100,150,255,0.2);
            padding: 10px;
            margin: 10px 0;
            border-left: 4px solid #4CAF50;
        }
        .error {
            background: rgba(255,100,100,0.2);
            border-left: 4px solid #ff4444;
        }
        .success {
            background: rgba(100,255,100,0.2);
            border-left: 4px solid #4CAF50;
        }
    </style>
</head>
<body>
    <h1>ğŸ› è°ƒè¯• about é‡éŸ³è¯†åˆ«</h1>
    
    <div class="debug">
        <h3>å•è¯ä¿¡æ¯</h3>
        <p><strong>å•è¯:</strong> about</p>
        <p><strong>éŸ³æ ‡:</strong> [É™ËˆbaÊŠt]</p>
        <p><strong>é¢„æœŸé‡éŸ³:</strong> bout (ç´¢å¼• 1,2,3,4)</p>
    </div>
    
    <div id="steps"></div>
    
    <div class="word" id="result"></div>
    
    <script>
        const logs = [];
        
        function log(message, type = 'info') {
            logs.push({ message, type });
            console.log(message);
        }
        
        function getWholeSyllable(word, vowelIndex) {
            log(`\n=== getWholeSyllable(${word}, ${vowelIndex}) ===`);
            const vowels = 'aeiou';
            const result = [];
            
            let centerVowel = vowelIndex;
            if (!vowels.includes(word[centerVowel])) {
                log(`âš ï¸ ç´¢å¼• ${centerVowel} ä¸æ˜¯å…ƒéŸ³: '${word[centerVowel]}'`, 'warning');
                for (let i = centerVowel; i < word.length; i++) {
                    if (vowels.includes(word[i])) {
                        centerVowel = i;
                        log(`âœ“ æ‰¾åˆ°å…ƒéŸ³åœ¨ç´¢å¼• ${i}: '${word[i]}'`, 'success');
                        break;
                    }
                }
            } else {
                log(`âœ“ ç´¢å¼• ${centerVowel} æ˜¯å…ƒéŸ³: '${word[centerVowel]}'`, 'success');
            }
            
            // å‘å·¦æ‰©å±•
            let left = centerVowel;
            log(`\nå‘å·¦æ‰©å±•ï¼Œä»ç´¢å¼• ${left} å¼€å§‹`);
            while (left > 0 && !vowels.includes(word[left - 1])) {
                left--;
                log(`  å‘å·¦åˆ°ç´¢å¼• ${left}: '${word[left]}'`);
            }
            log(`âœ“ å·¦è¾¹ç•Œ: ${left}`);
            
            // å‘å³æ‰©å±•
            let right = centerVowel;
            log(`\nå‘å³æ‰©å±•ï¼Œä»ç´¢å¼• ${right} å¼€å§‹`);
            
            // åŒ…å«è¿ç»­å…ƒéŸ³
            while (right < word.length - 1 && vowels.includes(word[right + 1])) {
                right++;
                log(`  åŒ…å«è¿ç»­å…ƒéŸ³ ${right}: '${word[right]}'`);
            }
            
            // åŒ…å«åé¢çš„è¾…éŸ³
            let consonantCount = 0;
            let tempRight = right;
            log(`\nè®¡ç®—åé¢çš„è¾…éŸ³æ•°é‡`);
            while (tempRight < word.length - 1 && !vowels.includes(word[tempRight + 1])) {
                consonantCount++;
                tempRight++;
                log(`  è¾…éŸ³ ${tempRight}: '${word[tempRight]}'`);
            }
            log(`âœ“ åé¢æœ‰ ${consonantCount} ä¸ªè¾…éŸ³`);
            
            if (tempRight < word.length - 1) {
                const half = Math.ceil(consonantCount / 2);
                right += half;
                log(`âš ï¸ åé¢è¿˜æœ‰å…ƒéŸ³ï¼Œå–ä¸€åŠè¾…éŸ³: ${half}`, 'warning');
            } else {
                right = tempRight;
                log(`âœ“ åé¢æ²¡æœ‰å…ƒéŸ³äº†ï¼Œå–æ‰€æœ‰è¾…éŸ³`, 'success');
            }
            log(`âœ“ å³è¾¹ç•Œ: ${right}`);
            
            for (let i = left; i <= right && i < word.length; i++) {
                result.push(i);
            }
            
            log(`\nâœ“ éŸ³èŠ‚èŒƒå›´: [${result.join(', ')}] â†’ "${result.map(i => word[i]).join('')}"`, 'success');
            return result;
        }
        
        function getStressPositions(word, phonetic) {
            log(`\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'info');
            log(`å¼€å§‹å¤„ç†å•è¯: ${word}`, 'info');
            log(`éŸ³æ ‡: ${phonetic}`, 'info');
            log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`, 'info');
            
            if (!word || !phonetic) {
                return [];
            }
            
            const lowerWord = word.toLowerCase();
            
            // 1. æŸ¥æ‰¾é‡éŸ³ç¬¦å·
            log(`\nã€æ­¥éª¤1ã€‘æŸ¥æ‰¾é‡éŸ³ç¬¦å·`);
            const stressPattern = /[ËˆËŒ]([É™Ã¦É‘É’É”ÉªiËÉœÉ›eÊŠuËÊŒÉ”ËÉªÉ™eÉªaÉªÉ”ÉªÉ™ÊŠeÉ™ÉªÉ™ÊŠÉ™aÊŠ]+)/g;
            const matches = [];
            let match;
            
            let searchPhonetic = phonetic;
            stressPattern.lastIndex = 0; // é‡ç½®æ­£åˆ™
            
            while ((match = stressPattern.exec(searchPhonetic)) !== null) {
                const info = {
                    index: match.index,
                    vowelSound: match[1],
                    type: searchPhonetic[match.index],
                    fullMatch: match[0]
                };
                matches.push(info);
                log(`  æ‰¾åˆ°é‡éŸ³: ${info.type}${info.vowelSound} (ç´¢å¼• ${info.index})`, 'success');
            }
            
            if (matches.length === 0) {
                log(`âš ï¸ æ²¡æœ‰æ‰¾åˆ°é‡éŸ³ç¬¦å·ï¼Œä½¿ç”¨é»˜è®¤è§„åˆ™`, 'warning');
                const vowels = 'aeiou';
                for (let i = 0; i < lowerWord.length; i++) {
                    if (vowels.includes(lowerWord[i])) {
                        return getWholeSyllable(lowerWord, i);
                    }
                }
                return Array.from({length: lowerWord.length}, (_, i) => i);
            }
            
            // 2. ä¼˜å…ˆå¤„ç†ä¸»é‡éŸ³
            log(`\nã€æ­¥éª¤2ã€‘ç­›é€‰é‡éŸ³ç±»å‹`);
            const primaryStress = matches.filter(m => m.type === 'Ëˆ');
            const stressesToProcess = primaryStress.length > 0 ? primaryStress : matches;
            
            if (primaryStress.length > 0) {
                log(`âœ“ æ‰¾åˆ° ${primaryStress.length} ä¸ªä¸»é‡éŸ³ï¼Œå¿½ç•¥æ¬¡é‡éŸ³`, 'success');
            } else {
                log(`âš ï¸ æ²¡æœ‰ä¸»é‡éŸ³ï¼Œä½¿ç”¨ ${matches.length} ä¸ªæ¬¡é‡éŸ³`, 'warning');
            }
            
            const result = [];
            const vowels = 'aeiou';
            
            // 3. è®¡ç®—éŸ³èŠ‚ä½ç½®
            stressesToProcess.forEach((stressMatch, idx) => {
                log(`\nã€æ­¥éª¤3.${idx + 1}ã€‘å¤„ç†é‡éŸ³: ${stressMatch.type}${stressMatch.vowelSound}`);
                
                const beforeStress = phonetic.substring(0, stressMatch.index);
                log(`  é‡éŸ³å‰çš„éŸ³æ ‡: "${beforeStress}"`);
                
                const syllablesBefore = (beforeStress.match(/[É™Ã¦É‘É’É”ÉªiËÉœÉ›eÊŠuËÊŒÉ”ËaÊŠ]+/g) || []).length;
                log(`  é‡éŸ³å‰çš„éŸ³èŠ‚æ•°: ${syllablesBefore}`);
                
                log(`\nã€æ­¥éª¤4ã€‘åœ¨å•è¯ä¸­æŸ¥æ‰¾ç¬¬ ${syllablesBefore} ä¸ªå…ƒéŸ³`);
                let vowelCount = 0;
                for (let i = 0; i < lowerWord.length; i++) {
                    if (vowels.includes(lowerWord[i])) {
                        log(`  å…ƒéŸ³#${vowelCount}: ç´¢å¼•${i} = '${lowerWord[i]}'`);
                        if (vowelCount === syllablesBefore) {
                            log(`\nâœ“âœ“âœ“ åŒ¹é…ï¼æ‰¾åˆ°é‡éŸ³å…ƒéŸ³åœ¨ç´¢å¼• ${i}`, 'success');
                            const syllablePositions = getWholeSyllable(lowerWord, i);
                            syllablePositions.forEach(pos => {
                                if (!result.includes(pos)) {
                                    result.push(pos);
                                }
                            });
                            break;
                        }
                        vowelCount++;
                    }
                }
            });
            
            if (result.length === 0) {
                log(`\nâš ï¸ æœªæ‰¾åˆ°åŒ¹é…ï¼Œä½¿ç”¨é»˜è®¤è§„åˆ™`, 'error');
                const vowels = 'aeiou';
                for (let i = 0; i < lowerWord.length; i++) {
                    if (vowels.includes(lowerWord[i])) {
                        return getWholeSyllable(lowerWord, i);
                    }
                }
            }
            
            log(`\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'success');
            log(`âœ“âœ“âœ“ æœ€ç»ˆç»“æœ: [${result.sort((a, b) => a - b).join(', ')}]`, 'success');
            log(`âœ“âœ“âœ“ å¯¹åº”å­—æ¯: "${result.sort((a, b) => a - b).map(i => lowerWord[i]).join('')}"`, 'success');
            log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n`, 'success');
            
            return result.sort((a, b) => a - b);
        }
        
        // æµ‹è¯•
        const word = 'about';
        const phonetic = '[É™ËˆbaÊŠt]';
        const positions = getStressPositions(word, phonetic);
        
        // æ˜¾ç¤ºæ­¥éª¤
        let stepsHtml = '';
        logs.forEach(log => {
            const className = log.type === 'error' ? 'step error' : 
                             log.type === 'warning' ? 'step' : 
                             log.type === 'success' ? 'step success' : 'step';
            stepsHtml += `<div class="${className}">${log.message}</div>`;
        });
        document.getElementById('steps').innerHTML = stepsHtml;
        
        // æ˜¾ç¤ºç»“æœ
        let resultHtml = '<div>';
        for (let i = 0; i < word.length; i++) {
            if (positions.includes(i)) {
                resultHtml += `<span class="stress">${word[i]}</span>`;
            } else {
                resultHtml += `<span class="normal">${word[i]}</span>`;
            }
        }
        resultHtml += '</div>';
        resultHtml += `<p style="font-size: 20px;">è¯†åˆ«ä½ç½®: [${positions.join(', ')}] â†’ "${positions.map(i => word[i]).join('')}"</p>`;
        resultHtml += `<p style="font-size: 20px;">é¢„æœŸä½ç½®: [1, 2, 3, 4] â†’ "bout"</p>`;
        
        document.getElementById('result').innerHTML = resultHtml;
    </script>
</body>
</html>
