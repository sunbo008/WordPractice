<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>测试 father</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 40px;
            background: #1e3c72;
            color: white;
        }
        .word {
            font-size: 64px;
            margin: 20px 0;
        }
        .stress { color: #ff4444; font-weight: bold; }
        .normal { color: #ffffff; }
        .debug {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <h1>测试 father 重音识别</h1>
    
    <div class="debug">
        <h3>单词信息</h3>
        <p><strong>单词:</strong> father</p>
        <p><strong>音标:</strong> [ˈfɑːðə]</p>
        <p><strong>重音符号:</strong> ˈ 在开头</p>
        <p><strong>预期重音:</strong> fa (第一音节)</p>
    </div>
    
    <div class="word" id="result"></div>
    
    <div class="debug" id="analysis"></div>
    
    <script>
        // 从 vocabulary-manager-v2.js 复制的算法
        function getStressPositions(word, phonetic) {
            console.log('=== 分析 father ===');
            console.log('单词:', word);
            console.log('音标:', phonetic);
            
            const lowerWord = word.toLowerCase();
            
            // 查找重音符号
            const stressPattern = /[ˈˌ]([əæɑɒɔɪiːɜɛeʊuːʌɔːɪəeɪaɪɔɪəʊeəɪəʊəaʊ]+)/g;
            const matches = [];
            let match;
            
            while ((match = stressPattern.exec(phonetic)) !== null) {
                matches.push({
                    index: match.index,
                    vowelSound: match[1],
                    type: phonetic[match.index]
                });
                console.log('找到重音:', phonetic[match.index], match[1], '位置:', match.index);
            }
            
            if (matches.length === 0) {
                console.log('⚠️ 没有找到重音符号');
                return [];
            }
            
            console.log('找到', matches.length, '个重音符号');
            
            // 优先主重音
            const primaryStress = matches.filter(m => m.type === 'ˈ');
            const stressesToProcess = primaryStress.length > 0 ? primaryStress : matches;
            
            console.log('处理重音数量:', stressesToProcess.length);
            
            const result = [];
            const vowels = 'aeiou';
            
            stressesToProcess.forEach((stressMatch, idx) => {
                console.log(`\n处理重音 ${idx + 1}:`);
                const beforeStress = phonetic.substring(0, stressMatch.index);
                console.log('  重音前的音标:', beforeStress);
                
                const syllablesBefore = (beforeStress.match(/[əæɑɒɔɪiːɜɛeʊuːʌɔːaʊ]+/g) || []).length;
                console.log('  重音前的音节数:', syllablesBefore);
                
                console.log('  在单词中查找第', syllablesBefore, '个元音');
                let vowelCount = 0;
                for (let i = 0; i < lowerWord.length; i++) {
                    if (vowels.includes(lowerWord[i])) {
                        console.log(`    元音 ${vowelCount}: ${lowerWord[i]} at ${i}`);
                        if (vowelCount === syllablesBefore) {
                            console.log(`    ✓ 匹配！找到重音元音`);
                            
                            // 扩展为整个音节
                            const syllable = getWholeSyllable(lowerWord, i);
                            console.log('    音节范围:', syllable, '→', syllable.map(idx => lowerWord[idx]).join(''));
                            
                            syllable.forEach(pos => {
                                if (!result.includes(pos)) {
                                    result.push(pos);
                                }
                            });
                            break;
                        }
                        vowelCount++;
                    }
                }
            });
            
            console.log('\n最终结果:', result, '→', result.map(i => lowerWord[i]).join(''));
            return result.sort((a, b) => a - b);
        }
        
        function getWholeSyllable(word, vowelIndex) {
            console.log('    扩展音节，从元音索引', vowelIndex, '(', word[vowelIndex], ')');
            const vowels = 'aeiou';
            const result = [];
            
            let centerVowel = vowelIndex;
            
            // 向左扩展
            let left = centerVowel;
            let consonantsBeforeCount = 0;
            let tempLeft = left - 1;
            while (tempLeft >= 0 && !vowels.includes(word[tempLeft])) {
                consonantsBeforeCount++;
                tempLeft--;
            }
            console.log('    前面有', consonantsBeforeCount, '个辅音');
            
            if (tempLeft >= 0) {
                if (consonantsBeforeCount === 1) {
                    left = left - 1;
                    console.log('    单个辅音，包含:', word[left]);
                } else if (consonantsBeforeCount >= 2) {
                    left = left - Math.ceil(consonantsBeforeCount / 2);
                    console.log('    多个辅音，取后一半');
                }
            } else {
                left = 0;
                console.log('    单词开头，取所有');
            }
            
            // 向右扩展
            let right = centerVowel;
            while (right < word.length - 1 && vowels.includes(word[right + 1])) {
                right++;
            }
            
            let consonantsAfterCount = 0;
            let tempRight = right;
            while (tempRight < word.length - 1 && !vowels.includes(word[tempRight + 1])) {
                consonantsAfterCount++;
                tempRight++;
            }
            console.log('    后面有', consonantsAfterCount, '个辅音');
            
            if (tempRight < word.length - 1) {
                if (consonantsAfterCount >= 2) {
                    right += Math.floor(consonantsAfterCount / 2);
                }
            } else {
                right = tempRight;
            }
            
            console.log('    左边界:', left, '右边界:', right);
            
            for (let i = left; i <= right && i < word.length; i++) {
                result.push(i);
            }
            
            return result;
        }
        
        // 测试
        const word = 'father';
        const phonetic = '[ˈfɑːðə]';
        const positions = getStressPositions(word, phonetic);
        
        // 显示结果
        let resultHtml = '<div>';
        for (let i = 0; i < word.length; i++) {
            if (positions.includes(i)) {
                resultHtml += `<span class="stress">${word[i]}</span>`;
            } else {
                resultHtml += `<span class="normal">${word[i]}</span>`;
            }
        }
        resultHtml += '</div>';
        resultHtml += `<p style="font-size: 20px;">识别位置: [${positions.join(', ')}] → "${positions.map(i => word[i]).join('')}"</p>`;
        resultHtml += `<p style="font-size: 20px;">预期位置: [0, 1, 2] → "fath"（fa+半个th）</p>`;
        
        document.getElementById('result').innerHTML = resultHtml;
        
        // 分析
        let analysis = '<h3>详细分析</h3>';
        analysis += '<p><strong>father 音节划分:</strong> fa-ther</p>';
        analysis += '<p><strong>重音符号 ˈ 位置:</strong> 在音标开头（[ˈfɑːðə]）</p>';
        analysis += '<p><strong>计算过程:</strong></p>';
        analysis += '<ul>';
        analysis += '<li>重音符号前的音标: "["（只有括号，没有元音）</li>';
        analysis += '<li>前面的音节数: 0</li>';
        analysis += '<li>在单词中查找第 0 个元音: f[a]ther（索引0处没有元音！）</li>';
        analysis += '<li>第 0 个元音应该是 "a"（索引1）</li>';
        analysis += '</ul>';
        analysis += '<p><strong>问题:</strong> 音标以 [ˈf... 开头，算法计算前面有0个音节，应该查找单词的第0个元音（从索引0开始的第一个元音）</p>';
        
        document.getElementById('analysis').innerHTML = analysis;
    </script>
</body>
</html>
